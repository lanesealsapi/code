<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Small Bet'em Hold'em — You vs Bot</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#0f1724;color:#e6eef6;display:flex;align-items:center;justify-content:center;height:100vh;margin:0}
  .table{width:980px;max-width:96%;background:#071022;padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .row{display:flex;gap:12px;align-items:center}
  .center{justify-content:center}
  .cards{display:flex;gap:8px}
  .card{width:56px;height:80px;border-radius:6px;background:#fff;color:#000;display:grid;place-items:center;font-weight:700}
  .card.back{background:linear-gradient(135deg,#0b7  ,#07f);color:#042}
  .panel{margin-left:auto;text-align:right}
  button{background:#0aa;border:0;padding:8px 12px;border-radius:8px;color:#022;margin-left:8px;cursor:pointer}
  .muted{color:#98a0b3;font-size:13px}
  .big{font-size:18px;font-weight:700}
  .status{margin-top:10px;color:#9ff}
  .controls{margin-top:12px;display:flex;gap:8px;align-items:center}
  input[type=number]{width:90px;padding:8px;border-radius:8px;border:0}
  .log{margin-top:12px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;max-height:120px;overflow:auto;font-size:13px}
</style>
</head>
<body>
  <div class="table" id="table">
    <div class="row">
      <div>
        <div class="big">Small Bet'em Hold'em — You vs Bot</div>
        <div class="muted">Simple demo: shuffled deck, random bot decisions, showdown hand compare</div>
      </div>
      <div class="panel">
        <div>Pot: <span id="pot">0</span></div>
        <div>SB: <span id="sb">5</span> • BB: <span id="bb">10</span></div>
      </div>
    </div>

    <hr style="border:0;border-top:1px solid rgba(255,255,255,0.04);margin:12px 0">

    <div class="row">
      <div style="width:50%">
        <div class="muted">Bot</div>
        <div class="cards" id="bot-cards">
          <div class="card back">?</div><div class="card back">?</div>
        </div>
        <div class="muted">Chips: <span id="bot-chips">1000</span></div>
      </div>

      <div style="width:50%;text-align:right">
        <div class="muted">You</div>
        <div class="cards" id="user-cards">
          <div class="card">?</div><div class="card">?</div>
        </div>
        <div class="muted">Chips: <span id="user-chips">1000</span></div>
      </div>
    </div>

    <div style="margin-top:12px">
      <div class="muted">Board</div>
      <div class="cards" id="board">
        <div class="card back">?</div><div class="card back">?</div><div class="card back">?</div><div class="card back">?</div><div class="card back">?</div>
      </div>
    </div>

    <div class="status" id="status">Click Deal to start a hand.</div>

    <div class="controls">
      <button id="deal">Deal</button>
      <button id="fold" disabled>Fold</button>
      <button id="check" disabled>Check</button>
      <button id="call" disabled>Call</button>
      <button id="bet" disabled>Bet</button>
      <input id="bet-amt" type="number" value="20" min="1" />
      <div style="margin-left:auto">
        <button id="next">Next (advance)</button>
      </div>
    </div>

    <div class="log" id="log"></div>
  </div>

<script>
/* Very small Texas Hold'em flow with dumb bot
 - No side pots
 - Small blind / big blind pre-set
 - Bot decisions are randomized within simple heuristics
 - Hand evaluator: rank by hand strength using basic score (sufficient for demo)
*/

const RANKS = "23456789TJQKA";
const SUITS = "♠♥♦♣";

function makeDeck(){ const d=[]; for(let r=0;r<13;r++) for(let s=0;s<4;s++) d.push({r:RANKS[r],ri:r,s:SUITS[s]}); return d; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function cardLabel(c){ return c.r + c.s; }

function draw(n){ return deck.splice(0,n); }

// Minimal evaluator: returns array [category, tiebreaker...], higher is better
// Categories: 8: straight flush,7:4kind,6:full house,5:flush,4:straight,3:3kind,2:two pair,1:pair,0:high
function evaluate7(cards){
  // map ranks to counts
  const counts = {}; const suits={};
  const vals = cards.map(c=>RANKS.indexOf(c.r)).sort((a,b)=>b-a); // high to low
  for(const c of cards){ counts[c.r]=(counts[c.r]||0)+1; suits[c.s]=(suits[c.s]||0)+1; }
  const isFlush = Object.values(suits).some(x=>x>=5);
  // straight detection with unique ranks
  const uniq = [...new Set(vals)].sort((a,b)=>b-a);
  // handle wheel (A-2-3-4-5)
  let straightHigh = -1;
  for(let i=0;i<uniq.length;i++){
    let h=uniq[i], len=1;
    for(let j=i+1;j<uniq.length;j++){
      if(uniq[j]===uniq[j-1]-1) len++; else break;
    }
    if(len>=5){ straightHigh = Math.max(straightHigh, uniq[i]); }
  }
  // wheel
  if(uniq.includes(12) && uniq.includes(3) && uniq.includes(2) && uniq.includes(1) && uniq.includes(0)) straightHigh = Math.max(straightHigh,3);

  // counts analysis
  const byCount = {};
  for(const r in counts){ const c=counts[r]; if(!byCount[c]) byCount[c]=[]; byCount[c].push(RANKS.indexOf(r)); }
  for(const k in byCount) byCount[k].sort((a,b)=>b-a);

  // straight flush quick check
  if(isFlush){
    // filter suits that have >=5 and check straight within that suit
    for(const s in suits){ if(suits[s]>=5){
      const suited = cards.filter(c=>c.s===s).map(c=>RANKS.indexOf(c.r)).sort((a,b)=>b-a);
      const u=[...new Set(suited)];
      for(let i=0;i<u.length;i++){
        let len=1;
        for(let j=i+1;j<u.length;j++){
          if(u[j]===u[j-1]-1) len++; else break;
        }
        if(len>=5) return [8,u[i]]; // straight flush
      }
      // wheel check for suited
      if(u.includes(12) && u.includes(3) && u.includes(2) && u.includes(1) && u.includes(0)) return [8,3];
    }}
  }

  if(byCount[4]) return [7, ...byCount[4], ...(byCount[1]||[])];
  if(byCount[3] && byCount[2]) return [6, ...byCount[3], ...byCount[2]];
  if(isFlush) return [5, ...vals];
  if(straightHigh>=0) return [4, straightHigh];
  if(byCount[3]) return [3, ...byCount[3], ...vals];
  if(byCount[2] && byCount[2].length>=2) return [2, ...byCount[2].slice(0,2), ...vals];
  if(byCount[2]) return [1, ...byCount[2], ...vals];
  return [0, ...vals];
}

function cmpHand(a,b){
  for(let i=0;i<Math.max(a.length,b.length);i++){
    const ai = a[i]||0, bi=b[i]||0;
    if(ai>bi) return 1;
    if(ai<bi) return -1;
  }
  return 0;
}

/* Game state */
let deck = [], board = [], pot = 0;
let user = {chips:1000, hand:[]}, bot = {chips:1000, hand:[]};
const SB = 5, BB = 10;
let toAct = null; // 'user' or 'bot'
let currentBet = 0; // amount to call
let contribution = {user:0,bot:0};
let phase = 'idle'; // idle, preflop, flop, turn, river, showdown
const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
const potEl = document.getElementById('pot');
const userCardsEl = document.getElementById('user-cards');
const botCardsEl = document.getElementById('bot-cards');
const boardEl = document.getElementById('board');
const userChipsEl = document.getElementById('user-chips');
const botChipsEl = document.getElementById('bot-chips');

function log(s){ const d=document.createElement('div'); d.textContent=s; logEl.prepend(d); }

function render(){
  potEl.textContent = pot;
  userChipsEl.textContent = user.chips;
  botChipsEl.textContent = bot.chips;
  // user cards (show always)
  userCardsEl.innerHTML = '';
  for(const c of user.hand){
    const el = document.createElement('div'); el.className='card'; el.textContent = cardLabel(c); userCardsEl.appendChild(el);
  }
  // bot cards (hide unless showdown)
  botCardsEl.innerHTML = '';
  for(const c of bot.hand){
    const el = document.createElement('div'); el.className='card back'; el.textContent = phase==='showdown' ? cardLabel(c) : '?'; botCardsEl.appendChild(el);
  }
  // board
  boardEl.innerHTML='';
  for(let i=0;i<5;i++){
    const el = document.createElement('div'); el.className='card';
    if(i<board.length) { el.textContent = cardLabel(board[i]); el.classList.remove('back'); }
    else { el.textContent='?'; el.classList.add('back'); }
    boardEl.appendChild(el);
  }
}

function resetHand(){
  deck = shuffle(makeDeck());
  board = [];
  pot = 0;
  currentBet = BB;
  contribution = {user:0,bot:0};
  phase='idle';
  user.hand=[]; bot.hand=[];
  toAct = null;
  render(); document.getElementById('pot').textContent=pot;
}

function dealHole(){
  user.hand = draw(2);
  bot.hand = draw(2);
  // blinds
  user.chips -= SB; bot.chips -= BB; // user is small blind for simplicity; you can vary
  contribution.user = SB; contribution.bot = BB;
  pot = SB + BB;
  currentBet = BB;
  toAct = 'user'; // user acts first preflop (after posting SB)
  phase='preflop';
  log('Dealt hole cards. Pot: '+pot);
  render(); updateButtons();
}

function flop(){
  // burn one
  draw(1); board.push(...draw(3)); phase='flop'; currentBet=0; contribution.user=contribution.bot=0; toAct='user';
  log('Flop dealt.');
  render(); updateButtons();
}

function turn(){
  draw(1); board.push(...draw(1)); phase='turn'; currentBet=0; contribution.user=contribution.bot=0; toAct='user';
  log('Turn dealt.');
  render(); updateButtons();
}

function river(){
  draw(1); board.push(...draw(1)); phase='river'; currentBet=0; contribution.user=contribution.bot=0; toAct='user';
  log('River dealt.');
  render(); updateButtons();
}

function showdown(){
  phase='showdown';
  render();
  const userEval = evaluate7(user.hand.concat(board));
  const botEval = evaluate7(bot.hand.concat(board));
  const cmp = cmpHand(userEval, botEval);
  if(cmp>0){
    user.chips += pot; log('You win pot '+pot);
  } else if(cmp<0){
    bot.chips += pot; log('Bot wins pot '+pot);
  } else { // split
    const half = Math.floor(pot/2);
    user.chips += half; bot.chips += pot-half; log('Split pot '+pot);
  }
  pot = 0; render(); updateButtons();
  statusEl.textContent = 'Showdown. ' + (cmp>0 ? 'You win.' : cmp<0 ? 'Bot wins.' : 'Split.');
}

function endHandCleanup(){
  // small check for bankrupt
  if(user.chips<=0) statusEl.textContent='You are out of chips. Refresh to restart.';
  if(bot.chips<=0) statusEl.textContent='Bot is out of chips. You win!';
  updateButtons();
}

function botDecision(){
  // very dumb/randomized bot logic
  if(phase==='preflop' && currentBet>0){
    // if facing bet: random call/fold with slight preference to call if has pair or high cards
    const ranks = bot.hand.map(c=>RANKS.indexOf(c.r)).sort((a,b)=>b-a);
    const strong = ranks[0]>=10 || ranks[0]===12 || ranks[1]===12 || bot.hand[0].r===bot.hand[1].r;
    const roll = Math.random();
    if(roll < (strong ? 0.75 : 0.4)) return 'call';
    return 'fold';
  }
  // if no bet to call: random check or bet small
  const r = Math.random();
  if(r<0.6) return 'check';
  return 'bet';
}

function botActFor(amountToCall){
  const decision = botDecision();
  log('Bot decides to '+decision);
  if(decision==='fold'){
    // bot folds, user wins pot
    user.chips += pot; pot=0; log('Bot folded. You win pot.');
    phase='showdown'; render(); updateButtons(); endHandCleanup();
    statusEl.textContent='Bot folded.';
    return;
  }
  if(decision==='call'){
    const callAmt = Math.min(amountToCall, bot.chips);
    bot.chips -= callAmt; contribution.bot += callAmt; pot += callAmt;
    log('Bot calls '+callAmt);
    // proceed to next phase
    advancePhaseAfterBet();
    render(); updateButtons();
    return;
  }
  if(decision==='check'){
    log('Bot checks');
    advancePhaseAfterBet();
    render(); updateButtons();
    return;
  }
  if(decision==='bet'){
    const betAmt = Math.min( Math.max(BB, Math.floor(Math.random()*50)+10), bot.chips );
    bot.chips -= betAmt; contribution.bot += betAmt; pot += betAmt;
    currentBet = betAmt; // user must call this
    toAct = 'user';
    log('Bot bets '+betAmt);
    render(); updateButtons();
    return;
  }
}

function advancePhaseAfterBet(){
  if(phase==='preflop') flop();
  else if(phase==='flop') turn();
  else if(phase==='turn') river();
  else if(phase==='river') showdown();
}

function updateButtons(){
  const disabled = (phase==='idle' || phase==='showdown' || user.chips<=0 || bot.chips<=0);
  document.getElementById('deal').disabled = (phase!=='idle' && phase!=='showdown') || user.chips<=0 || bot.chips<=0;
  document.getElementById('fold').disabled = disabled || (phase==='idle');
  document.getElementById('check').disabled = disabled || (currentBet>0);
  document.getElementById('call').disabled = disabled || (currentBet===0);
  document.getElementById('bet').disabled = disabled;
}

document.getElementById('deal').addEventListener('click', ()=>{
  resetHand();
  dealHole();
  statusEl.textContent = 'Preflop — your action.';
  render(); updateButtons();
});

document.getElementById('fold').addEventListener('click', ()=>{
  log('You folded. Bot wins pot '+pot);
  bot.chips += pot; pot=0; phase='showdown'; render(); updateButtons(); statusEl.textContent='You folded.';
  endHandCleanup();
});

document.getElementById('check').addEventListener('click', ()=>{
  log('You check.');
  // bot acts
  setTimeout(()=>{ botActFor(0); }, 300);
});

document.getElementById('call').addEventListener('click', ()=>{
  const toCall = currentBet - contribution.user;
  const callAmt = Math.min(toCall, user.chips);
  user.chips -= callAmt; contribution.user += callAmt; pot += callAmt;
  log('You call '+callAmt);
  // advance
  setTimeout(()=>{ botActFor(0); }, 300);
  render(); updateButtons();
});

document.getElementById('bet').addEventListener('click', ()=>{
  const amt = Math.max(1, Math.min(user.chips, Number(document.getElementById('bet-amt').value || BB)));
  user.chips -= amt; contribution.user += amt; pot += amt;
  currentBet = amt; toAct='bot';
  log('You bet '+amt);
  render(); updateButtons();
  // bot responds
  setTimeout(()=>{ botActFor(amt); }, 300);
});

document.getElementById('next').addEventListener('click', ()=>{
  // advance phases if possible (for demo/testing)
  if(phase==='preflop') flop();
  else if(phase==='flop') turn();
  else if(phase==='turn') river();
  else if(phase==='river') showdown();
  render(); updateButtons();
});

// initialize
resetHand();
render();
updateButtons();
</script>
</body>
</html>
