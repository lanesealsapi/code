<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Learning Emoji Simulator</title>
<style>
  body, html {
    margin:0;
    padding:0;
    overflow:hidden;
    font-family:'Comic Sans MS',sans-serif;
    background:#d0f0fd;
  }
  canvas { display:block; }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Emoji types and names
const emojiTypes = ['😄','😎','🤪','🥳','🐱','🍕','🎈','🎵'];
const names = ['Bubbles','Coolio','Wacky','Party','Whiskers','Slice','Balloon','Tune'];

// Phrases
const phrases = [
  "Wow, what a day!",
  "Let's party like there's no tomorrow!",
  "I just love pizza time!",
  "Did you see that crazy trick?",
  "Hahaha, you're hilarious!",
  "I need a nap after that!",
  "Catch me if you can!",
  "Boing boing, let's bounce!",
  "Life is too short for boring things!",
  "Zoom zoom, off we go!",
  "Music makes everything better!",
  "Oops! That was unexpected!",
  "This is totally amazing!",
  "Let's dance all night long!",
  "Mmm, delicious pizza!",
  "Who needs sleep anyway?",
  "Silly faces are the best!",
  "Time for a crazy adventure!",
  "Wow, I can't believe this!",
  "Hooray, confetti everywhere!",
  "Life is full of surprises!",
  "Keep smiling, it's contagious!",
  "Yay, we're unstoppable!",
  "Let's make some noise!",
  "Boop boop, hello friend!",
  "Fun times are the best times!",
  "Laugh until your belly hurts!",
  "Adventure awaits, let's go!"
];

// Neural network learning rate
const alpha = 0.05;

// Emoji class
class Emoji {
  constructor(index){
    this.x = Math.random()*canvas.width;
    this.y = Math.random()*canvas.height;
    this.vx = (Math.random()-0.5)*3;
    this.vy = (Math.random()-0.5)*3;
    this.size = 48;
    this.type = emojiTypes[index % emojiTypes.length];
    this.name = names[index % names.length];
    // Initialize phrase probabilities uniformly
    this.phraseWeights = Array(phrases.length).fill(1/phrases.length);
    this.phrase = this.choosePhrase();
    this.speechTime = Math.random()*200 + 100;
  }

  // Choose phrase probabilistically
  choosePhrase(){
    let sum = this.phraseWeights.reduce((a,b)=>a+b,0);
    let r = Math.random()*sum;
    let acc = 0;
    for(let i=0;i<this.phraseWeights.length;i++){
      acc += this.phraseWeights[i];
      if(r <= acc) return phrases[i];
    }
    return phrases[0];
  }

  move(){
    this.x += this.vx;
    this.y += this.vy;
    if(this.x < 0 || this.x > canvas.width - this.size) this.vx *= -1;
    if(this.y < 0 || this.y > canvas.height - this.size) this.vy *= -1;

    this.speechTime--;
    if(this.speechTime <= 0){
      this.phrase = this.choosePhrase();
      this.speechTime = Math.random()*200 + 100;
    }
  }

  // When interacting with another emoji, learn which phrases “work”
  interact(other){
    const dist = Math.sqrt((other.x-this.x)**2 + (other.y-this.y)**2);
    if(dist < 100){
      // Small learning: increase weights for phrases that are currently chosen by the other emoji
      for(let i=0;i<phrases.length;i++){
        if(phrases[i] === other.phrase){
          this.phraseWeights[i] += alpha;
        } else {
          this.phraseWeights[i] *= (1-alpha);
        }
      }
      // Normalize weights
      const sum = this.phraseWeights.reduce((a,b)=>a+b,0);
      this.phraseWeights = this.phraseWeights.map(w=>w/sum);

      // Simple bounce
      this.vx *= -1;
      this.vy *= -1;
      other.vx *= -1;
      other.vy *= -1;
    }
  }

  draw(){
    // Draw emoji
    ctx.font = this.size + "px serif";
    ctx.fillText(this.type, this.x, this.y);

    // Draw speech bubble
    const padding = 6;
    ctx.font = "16px Comic Sans MS";
    const textWidth = ctx.measureText(this.phrase).width;
    const bubbleX = this.x - textWidth/2 + this.size/2;
    const bubbleY = this.y - this.size - 30;
    const bubbleWidth = textWidth + padding*2;
    const bubbleHeight = 24;

    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, 8);
    ctx.fill();
    ctx.stroke();

    // Bubble text
    ctx.fillStyle = "#000";
    ctx.fillText(this.phrase, bubbleX + padding, bubbleY + 18);
  }
}

// RoundRect polyfill
CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r){
  if (w<2*r) r=w/2;
  if (h<2*r) r=h/2;
  this.beginPath();
  this.moveTo(x+r,y);
  this.arcTo(x+w,y,x+w,y+h,r);
  this.arcTo(x+w,y+h,x,y+h,r);
  this.arcTo(x,y+h,x,y,r);
  this.arcTo(x,y,x+w,y,r);
  this.closePath();
  return this;
}

// Initialize emojis
let emojis = [];
for(let i=0;i<12;i++) emojis.push(new Emoji(i));

function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Check interactions
  for(let i=0;i<emojis.length;i++){
    for(let j=i+1;j<emojis.length;j++){
      emojis[i].interact(emojis[j]);
    }
  }

  // Move and draw
  emojis.forEach(e=>{
    e.move();
    e.draw();
  });

  requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', ()=>{
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});
</script>

</body>
</html>
