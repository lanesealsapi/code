<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Epic Meme Studio ‚Äî Humor + Create</title>
<style>
  :root{
    --bg:#0b1220; --card:#071021; --muted:#9aa6b2; --accent:#7dd3fc; --accent2:#f97316;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial;background:linear-gradient(180deg,#02101a 0%,#071824 100%);color:#e6eef6}
  .app{max-width:1150px;margin:18px auto;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 40px rgba(2,6,23,0.6)}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  header h1{margin:0;font-size:20px}
  .row{display:flex;gap:12px;margin-top:12px}
  .left{width:640px}
  .right{flex:1;min-width:320px}
  .card{background:var(--card);padding:12px;border-radius:10px}
  .canvasWrap{background:#041018;border-radius:8px;padding:10px;display:flex;justify-content:center;align-items:center;min-height:420px;position:relative}
  #mainCanvas{background:#000;border-radius:6px;max-width:100%;height:auto;display:block}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .btn{background:var(--accent);color:#012;padding:8px 10px;border-radius:8px;border:none;cursor:pointer}
  .btn2{background:transparent;color:var(--muted);padding:6px 8px;border:1px solid rgba(255,255,255,0.03);border-radius:8px;cursor:pointer}
  input[type=file]{display:none}
  label.upload{background:linear-gradient(90deg,#0f1724,#0b1220);border:1px dashed #16324a;padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
  .toolbar{display:flex;flex-direction:column;gap:8px}
  .small{font-size:13px;color:var(--muted)}
  .layers{max-height:180px;overflow:auto;margin-top:8px;padding-right:8px}
  .layerRow{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:6px;cursor:pointer}
  .layerRow.active{background:linear-gradient(90deg, rgba(125,211,252,0.06), rgba(249,115,22,0.02));}
  .props{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .input{background:var(--glass);border:1px solid rgba(255,255,255,0.02);padding:8px;border-radius:6px;color:inherit}
  .flex{display:flex;gap:8px;align-items:center}
  .stamps{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .stamp{cursor:pointer;font-size:22px;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.03)}
  footer{margin-top:12px;color:var(--muted);font-size:13px}
  .hint{font-size:12px;color:var(--muted);margin-top:6px}
  .scoreBox{background:linear-gradient(90deg, rgba(125,211,252,0.03), rgba(249,115,22,0.02));padding:8px;border-radius:6px}
</style>
</head>
<body>
<div class="app">
  <header>
    <div>
      <h1>Epic Meme Studio</h1>
      <div class="small">Create, style, analyze humor, share ‚Äî all client-side.</div>
    </div>
    <div class="controls">
      <label class="upload" title="Upload an image"><input id="fileIn" type="file" accept="image/*">Upload image</label>
      <button id="pasteBtn" class="btn2" title="Paste image from clipboard (Ctrl+V)">Paste</button>
      <button id="downloadBtn" class="btn" title="Download final PNG">Download PNG</button>
      <button id="copyBtn" class="btn2" title="Copy final image to clipboard">Copy Image</button>
      <button id="shareBtn" class="btn2" title="Web Share (mobile/compatible)">Share</button>
    </div>
  </header>

  <div class="row">
    <div class="left card">
      <div class="canvasWrap" id="dropArea">
        <canvas id="mainCanvas" width="800" height="600"></canvas>
      </div>

      <div class="controls" style="margin-top:10px">
        <button id="addText" class="btn2">Add Text</button>
        <button id="addStamp" class="btn2">Add Stamp</button>
        <button id="analyzeHumor" class="btn">Analyze Humor</button>
        <button id="undoBtn" class="btn2">Undo</button>
      </div>

      <div class="hint">Drag an image into the canvas area, paste from clipboard, or use Upload. Click a text/stamp to select, drag to move, use handles to resize/rotate. Delete key removes selected layer.</div>
    </div>

    <div class="right card">
      <div style="display:flex;gap:12px">
        <div style="flex:1">
          <div class="small">Layers</div>
          <div class="layers" id="layersList"></div>
        </div>
        <div style="width:220px">
          <div class="small">Properties</div>
          <div class="props">
            <input id="txtContent" class="input" placeholder="Edit text (select layer first)"/>
            <div class="flex"><label class="small">Font</label>
              <select id="fontFamily" class="input" style="width:100%">
                <option value="Impact,Arial,Helvetica">Impact</option>
                <option value="Arial,Helvetica">Arial</option>
                <option value="Georgia,serif">Georgia</option>
                <option value="Comic Sans MS, cursive">Comic Sans</option>
              </select>
            </div>
            <div class="flex"><label class="small">Size</label><input id="fontSize" type="number" class="input" min="12" max="200" value="48" style="width:100%"></div>
            <div class="flex"><label class="small">Color</label><input id="fontColor" type="color" class="input" value="#FFFFFF" style="padding:2px"></div>
            <div class="flex"><label class="small">Stroke</label><input id="fontStroke" type="number" class="input" min="0" max="10" value="2"></div>
            <div class="flex"><label class="small">Align</label>
              <select id="fontAlign" class="input" style="width:100%"><option value="center">Center</option><option value="left">Left</option><option value="right">Right</option></select>
            </div>
            <div class="small">Stickers</div>
            <div class="stamps" id="stampPalette">
              <!-- small emoji stamps -->
              <button class="stamp">üòÇ</button>
              <button class="stamp">üî•</button>
              <button class="stamp">ü§°</button>
              <button class="stamp">üíÄ</button>
              <button class="stamp">üëç</button>
              <button class="stamp">üò≥</button>
              <button class="stamp">üí•</button>
              <button class="stamp">üê∂</button>
              <button class="stamp">üê±</button>
            </div>
            <div style="display:flex;gap:8px">
              <button id="bringFront" class="btn2">Bring Front</button>
              <button id="sendBack" class="btn2">Send Back</button>
            </div>
            <div style="display:flex;gap:8px">
              <button id="saveProject" class="btn2">Save Project</button>
              <button id="loadProject" class="btn2">Load Project</button>
            </div>
            <div class="scoreBox" id="humorBox" style="display:none">
              <div class="small">Humor Likelihood</div>
              <div id="humorScore" style="font-weight:700;font-size:20px">‚Äî</div>
              <div id="humorBreakdown" class="small" style="margin-top:6px"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="hint" style="margin-top:8px">Tip: use Impact + white text + black stroke for classic meme look. Try short punchy captions.</div>
    </div>
  </div>

  <footer>
    <div class="small">All editing & analysis runs in your browser. No images leave your device unless you choose to share/download them.</div>
  </footer>
</div>

<script>
/*
 Epic Meme Studio
 - Layers model: {id,type:'image'|'text'|'stamp',img?,text?,x,y,w,h,rot,font,size,color,stroke,align}
 - Simple transform controls: drag to move; scale by handles (corner resizing); rotate with handle (top)
 - For brevity we implement basic dragging and corner scale (no perfect UX but functional)
*/

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const dropArea = document.getElementById('dropArea');
const fileIn = document.getElementById('fileIn');
const layersList = document.getElementById('layersList');
const txtContent = document.getElementById('txtContent');
const fontFamily = document.getElementById('fontFamily');
const fontSize = document.getElementById('fontSize');
const fontColor = document.getElementById('fontColor');
const fontStroke = document.getElementById('fontStroke');
const fontAlign = document.getElementById('fontAlign');
const stampPalette = document.getElementById('stampPalette');
const addTextBtn = document.getElementById('addText');
const addStampBtn = document.getElementById('addStamp');
const analyzeHumorBtn = document.getElementById('analyzeHumor');
const humorBox = document.getElementById('humorBox');
const humorScoreEl = document.getElementById('humorScore');
const humorBreakdown = document.getElementById('humorBreakdown');
const downloadBtn = document.getElementById('downloadBtn');
const copyBtn = document.getElementById('copyBtn');
const shareBtn = document.getElementById('shareBtn');
const undoBtn = document.getElementById('undoBtn');
const saveProjectBtn = document.getElementById('saveProject');
const loadProjectBtn = document.getElementById('loadProject');
const pasteBtn = document.getElementById('pasteBtn');
const bringFrontBtn = document.getElementById('bringFront');
const sendBackBtn = document.getElementById('sendBack');

let layers = []; // top = last
let selectedId = null;
let history = [];
function pushHistory(){ history.push(JSON.stringify(layers)); if(history.length>30) history.shift(); }
function undo(){ if(history.length){ layers = JSON.parse(history.pop()); selectedId=null; render(); } }
undoBtn.addEventListener('click', undo);
document.addEventListener('keydown', (e)=>{ if(e.ctrlKey && e.key==='z') undo(); if(e.key==='Delete' && selectedId) { pushHistory(); layers = layers.filter(l=>l.id!==selectedId); selectedId=null; render(); } });

fileIn.addEventListener('change', async (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{ pushHistory(); const s = Math.min(canvas.width/img.width, canvas.height/img.height); layers.push({id:uid(), type:'image', img:img, x:(canvas.width-img.width*s)/2, y:(canvas.height-img.height*s)/2, w:img.width*s, h:img.height*s, rot:0}); render(); URL.revokeObjectURL(url); };
  img.src = url;
});

dropArea.addEventListener('dragover',(e)=>{ e.preventDefault(); dropArea.style.outline='2px dashed rgba(125,211,252,0.2)';});
dropArea.addEventListener('dragleave',()=>{ dropArea.style.outline='none';});
dropArea.addEventListener('drop',(e)=>{ e.preventDefault(); dropArea.style.outline='none'; const f = e.dataTransfer.files && e.dataTransfer.files[0]; if(f) { fileIn.files = e.dataTransfer.files; fileIn.dispatchEvent(new Event('change')); } });

pasteBtn.addEventListener('click', async ()=>{ alert('Press Ctrl+V (Cmd+V on Mac) to paste an image.'); });
document.addEventListener('paste', async (e)=>{ if(e.clipboardData){ const items = e.clipboardData.items; for(const it of items){ if(it.type.indexOf('image')!==-1){ const blob = it.getAsFile(); const url=URL.createObjectURL(blob); const img=new Image(); img.onload=()=>{ pushHistory(); const s = Math.min(canvas.width/img.width, canvas.height/img.height); layers.push({id:uid(),type:'image',img:img,x:(canvas.width-img.width*s)/2,y:(canvas.height-img.height*s)/2,w:img.width*s,h:img.height*s,rot:0}); render(); URL.revokeObjectURL(url); }; img.src=url; } } }});

function uid(){ return 'id_'+Math.random().toString(36).slice(2,9); }

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background darker
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  layers.forEach(layer=>{
    ctx.save();
    ctx.translate(layer.x + (layer.w||0)/2, layer.y + (layer.h||0)/2);
    ctx.rotate((layer.rot||0) * Math.PI/180);
    if(layer.type==='image'){
      ctx.drawImage(layer.img, -layer.w/2, -layer.h/2, layer.w, layer.h);
    } else if(layer.type==='text'){
      const size = layer.size||48;
      ctx.font = `${size}px ${layer.font || 'Impact, Arial'}`;
      ctx.textAlign = layer.align || 'center';
      ctx.textBaseline = 'middle';
      const lines = String(layer.text||'').split('\\n');
      // stroke for meme look
      ctx.lineWidth = (layer.stroke||2);
      ctx.strokeStyle = layer.strokeColor || '#000';
      ctx.fillStyle = layer.color || '#fff';
      const lineHeight = size * 1.05;
      const off = - (lines.length-1)/2 * lineHeight;
      for(let i=0;i<lines.length;i++){
        const y = off + i*lineHeight;
        if(ctx.lineWidth>0) ctx.strokeText(lines[i], 0, y);
        ctx.fillText(lines[i], 0, y);
      }
    } else if(layer.type==='stamp'){
      ctx.font = `${layer.size||48}px serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      if(layer.shadow) { ctx.shadowColor='rgba(0,0,0,0.4)'; ctx.shadowBlur=10; }
      ctx.fillText(layer.char||'üòÇ', 0, 0);
      ctx.shadowBlur=0;
    }
    // selection box
    if(layer.id === selectedId){
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(125,211,252,0.9)';
      ctx.strokeRect(- (layer.w|| (ctx.measureText(layer.text||'').width))/2 -8, - (layer.h|| (layer.size||48))/2 -8, (layer.w||ctx.measureText(layer.text||'').width)+16, (layer.h|| (layer.size||48))+16);
    }
    ctx.restore();
  });
  refreshLayerList();
  drawPreviewSmall();
}

function refreshLayerList(){
  layersList.innerHTML = '';
  for(let i=layers.length-1;i>=0;i--){
    const l = layers[i];
    const row = document.createElement('div');
    row.className = 'layerRow' + (l.id===selectedId ? ' active':'');
    row.innerHTML = `<div>${l.type==='image'? 'Image' : (l.type==='text' ? 'Text: '+(String(l.text||'')).slice(0,18) : 'Stamp: '+(l.char||''))}</div><div style="opacity:0.7;font-size:12px">${i}</div>`;
    row.onclick = ()=>{ selectedId = l.id; bindPropsToSelection(); render(); };
    layersList.appendChild(row);
  }
}

function bindPropsToSelection(){
  const sel = layers.find(x=>x.id===selectedId);
  if(!sel){ txtContent.value=''; fontSize.value=48; fontColor.value='#fff'; fontStroke.value=2; fontAlign.value='center'; return; }
  if(sel.type==='text'){
    txtContent.value = sel.text||'';
    fontFamily.value = sel.font || fontFamily.value;
    fontSize.value = sel.size || 48;
    fontColor.value = sel.color || '#fff';
    fontStroke.value = sel.stroke || 2;
    fontAlign.value = sel.align || 'center';
  } else {
    txtContent.value = sel.type==='stamp' ? (sel.char||'') : '';
  }
}

txtContent.addEventListener('input', ()=>{
  const sel = layers.find(x=>x.id===selectedId);
  if(!sel) return;
  pushHistory();
  if(sel.type==='text'){ sel.text = txtContent.value; sel.size = Number(fontSize.value); sel.font = fontFamily.value; sel.color = fontColor.value; sel.stroke = Number(fontStroke.value); sel.align = fontAlign.value; render(); }
});

fontFamily.addEventListener('change', ()=>{ const sel = layers.find(x=>x.id===selectedId); if(sel && sel.type==='text'){ pushHistory(); sel.font = fontFamily.value; render(); }});
fontSize.addEventListener('change', ()=>{ const sel = layers.find(x=>x.id===selectedId); if(sel && sel.type==='text'){ pushHistory(); sel.size = Number(fontSize.value); render(); }});
fontColor.addEventListener('change', ()=>{ const sel = layers.find(x=>x.id===selectedId); if(sel && sel.type==='text'){ pushHistory(); sel.color = fontColor.value; render(); }});
fontStroke.addEventListener('change', ()=>{ const sel = layers.find(x=>x.id===selectedId); if(sel && sel.type==='text'){ pushHistory(); sel.stroke = Number(fontStroke.value); render(); }});
fontAlign.addEventListener('change', ()=>{ const sel = layers.find(x=>x.id===selectedId); if(sel && sel.type==='text'){ pushHistory(); sel.align = fontAlign.value; render(); }});

stampPalette.addEventListener('click', (e)=>{ if(e.target.classList.contains('stamp')){ const txt = e.target.textContent; pushHistory(); layers.push({id:uid(), type:'stamp', char:txt, x:canvas.width/2-40 + Math.random()*80, y:canvas.height/2-40 + Math.random()*80, w:80, h:80, size:64, rot:0, shadow:true}); render(); }});

addTextBtn.addEventListener('click', ()=>{ pushHistory(); layers.push({id:uid(), type:'text', text:'TOP TEXT', x:canvas.width/2 - 180, y:60, w:360, h:80, size:56, font:'Impact, Arial', color:'#fff', stroke:6, strokeColor:'#000', align:'center', rot:0}); render(); });

addStampBtn.addEventListener('click', ()=>{ pushHistory(); layers.push({id:uid(), type:'stamp', char:'üòÇ', x:canvas.width/2, y:canvas.height/2, size:72, rot:0}); render(); });

// bring front / send back
bringFrontBtn.addEventListener('click', ()=>{ if(!selectedId) return; pushHistory(); const idx = layers.findIndex(l=>l.id===selectedId); if(idx>=0){ const [item] = layers.splice(idx,1); layers.push(item); render(); }});
sendBackBtn.addEventListener('click', ()=>{ if(!selectedId) return; pushHistory(); const idx = layers.findIndex(l=>l.id===selectedId); if(idx>=0){ const [item] = layers.splice(idx,1); layers.unshift(item); render(); }});

// basic drag/transform
let dragging = false, dragOffsetX=0, dragOffsetY=0, activeHandle=null;
canvas.addEventListener('mousedown', (e)=>{ const pos = getMousePos(e); const hit = hitTest(pos.x,pos.y); if(hit){ selectedId = hit.id; bindPropsToSelection(); dragging=true; dragOffsetX = pos.x - hit.x; dragOffsetY = pos.y - hit.y; } else { selectedId=null; } render(); });
canvas.addEventListener('mousemove', (e)=>{ if(!dragging) return; const pos = getMousePos(e); const sel = layers.find(l=>l.id===selectedId); if(sel){ sel.x = pos.x - dragOffsetX; sel.y = pos.y - dragOffsetY; } render(); });
canvas.addEventListener('mouseup', ()=>{ if(dragging){ pushHistory(); } dragging=false; activeHandle=null; });
canvas.addEventListener('mouseleave', ()=>{ if(dragging){ pushHistory(); } dragging=false; });

// simple hit test: check bounding box after rotation (approx)
function hitTest(mx,my){
  for(let i=layers.length-1;i>=0;i--){
    const l=layers[i];
    const cx = l.x + (l.w|| (l.text ? ctx.measureText(l.text).width : 0))/2;
    const cy = l.y + (l.h|| (l.size||48))/2;
    // approximate bounds
    const bw = l.w || (l.text ? Math.max(80, (l.text.length* (l.size||48)/2)) : (l.size||48));
    const bh = l.h || (l.size||48);
    const left = l.x, top = l.y, right = l.x + bw, bottom = l.y + bh;
    if(mx>=left && mx<=right && my>=top && my<=bottom){
      return {id:l.id, x: l.x + bw/2, y: l.y + bh/2};
    }
  }
  return null;
}

// helper preview (small)
function drawPreviewSmall(){
  // no-op for now, but could display scaled thumbnail
}

// Download PNG
downloadBtn.addEventListener('click', ()=>{ const dataURL = canvas.toDataURL('image/png'); const a = document.createElement('a'); a.href = dataURL; a.download = 'meme.png'; a.click(); });

// Copy image to clipboard (try)
copyBtn.addEventListener('click', async ()=>{
  try{
    canvas.toBlob(async (blob)=>{
      const item = new ClipboardItem({ 'image/png': blob });
      await navigator.clipboard.write([item]);
      alert('Image copied to clipboard.');
    });
  }catch(err){
    alert('Copy to clipboard failed. Your browser might not support image clipboard API.');
  }
});

// Web Share
shareBtn.addEventListener('click', async ()=>{
  if(navigator.canShare && navigator.canShare()){ // not all browsers support images via share
    canvas.toBlob(async (blob)=>{
      const filesArray = [ new File([blob], 'meme.png', { type: blob.type }) ];
      try{
        await navigator.share({ files: filesArray, text: 'Check out my meme!' });
      }catch(e){ console.log('share failed',e); alert('Share cancelled or failed'); }
    });
  } else {
    // fallback: share data URL link (copy link)
    const dataURL = canvas.toDataURL('image/png');
    prompt('Web Share is not available. You can copy the image data URL (very long) or download the PNG.', dataURL.slice(0,200)+'...'); 
  }
});

// Save / Load project JSON
saveProjectBtn.addEventListener('click', ()=>{
  const project = { layers: layers.map(l=>{ const copy = Object.assign({}, l); if(l.type==='image' && l.img){ copy.img = null; copy.imgData = canvas.toDataURL(); } return copy; }) };
  const data = 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(project));
  const a = document.createElement('a'); a.href=data; a.download='meme-project.json'; a.click();
});
loadProjectBtn.addEventListener('click', ()=>{ const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json'; inp.onchange = (e)=>{ const f = e.target.files[0]; const reader = new FileReader(); reader.onload = ()=>{ try{ const project = JSON.parse(reader.result); if(project.layers){ pushHistory(); layers = []; (async ()=>{ for(const pl of project.layers){ if(pl.imgData){ const img = new Image(); await new Promise(r=>{ img.onload=r; img.src = pl.imgData; }); pl.img = img; } layers.push(pl); } render(); })(); } }catch(err){ alert('Invalid project file') } }; reader.readAsText(f); }; inp.click(); });

// Humor analysis: improved proxies
analyzeHumorBtn.addEventListener('click', ()=>{
  if(layers.length===0){ alert('Add an image first'); return; }
  const imgLayer = layers.find(l=>l.type==='image') || layers[0];
  // render current canvas to temp, analyze pixels
  const id = ctx.getImageData(0,0,canvas.width,canvas.height);
  const stats = computeHumorFromImageData(id);
  humorBox.style.display = 'block';
  humorScoreEl.textContent = Math.round(stats.overall) + ' / 100';
  humorBreakdown.innerHTML = `Exaggeration: ${Math.round(stats.exaggeration)} ‚Ä¢ Color Fun: ${Math.round(stats.colorFun)} ‚Ä¢ Incongruity: ${Math.round(stats.incongruity)} ‚Ä¢ Expression: ${Math.round(stats.expression)} ‚Ä¢ Surprise: ${Math.round(stats.unexpected)}`;
  // provide caption suggestions (playful heuristics)
  const suggestions = captionSuggestions(stats);
  displaySuggestions(suggestions);
});

// compute humor proxies (more refined than random)
function computeHumorFromImageData(idata){
  const d = idata.data, w = idata.width, h = idata.height;
  let brightCount=0, darkCount=0, satSum=0, tot=0;
  // colorfulness metric (Hasler & Suesstrunk simplified)
  let rgSum=0,ybSum=0;
  for(let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    const mx = Math.max(r,g,b), mn = Math.min(r,g,b);
    if(mx>220) brightCount++;
    if(mn<30) darkCount++;
    const sat = (mx - mn)/(mx+1); satSum += sat;
    rgSum += Math.abs(r-g);
    ybSum += Math.abs(0.5*(r+g) - b);
    tot++;
  }
  const colorfulness = clamp(Math.sqrt((rgSum/tot)**2 + (ybSum/tot)**2)/2, 0, 255);
  const avgSat = clamp((satSum/tot)*100,0,100);
  // edge / expression proxy
  const lum = new Float32Array(w*h);
  for(let y=0,pi=0;y<h;y++){ for(let x=0;x<w;x++,pi+=4){ lum[y*w+x] = 0.2126*d[pi]+0.7152*d[pi+1]+0.0722*d[pi+2]; } }
  // sobel-ish
  let edgeSum=0;
  for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){ const gx = -lum[(y-1)*w+(x-1)] -2*lum[y*w+(x-1)] - lum[(y+1)*w+(x-1)] + lum[(y-1)*w+(x+1)] +2*lum[y*w+(x+1)] + lum[(y+1)*w+(x+1)]; const gy = -lum[(y-1)*w+(x-1)] -2*lum[(y-1)*w+x] - lum[(y-1)*w+(x+1)] + lum[(y+1)*w+(x-1)] +2*lum[(y+1)*w+x] + lum[(y+1)*w+(x+1)]; edgeSum += Math.hypot(gx,gy); } }
  const edgeDensity = clamp((edgeSum / (w*h)) / 20, 0,100);
  // heuristic proxies
  const exaggeration = clamp((brightCount+darkCount)/tot*120, 0,100);
  const colorFun = clamp((avgSat*0.6) + (colorfulness/2)*0.4, 0,100);
  // simple semantic incongruity proxy: if many small disconnected shapes exist, surprise increases (cheap)
  let smallBlobs=0;
  // (We won't do full connected components for speed; approximate by counting local variance)
  let localVar=0;
  for(let y=2;y<h-2;y+=6){ for(let x=2;x<w-2;x+=6){ const c = lum[y*w+x]; let v=0; for(let oy=-2;oy<=2;oy++) for(let ox=-2;ox<=2;ox++){ v += Math.abs(c - lum[(y+oy)*w+(x+ox)]); } localVar += v; }}
  localVar = localVar / ((Math.floor(h/6))*(Math.floor(w/6)));
  const incongruity = clamp(Math.min(100, localVar / 40 * 100), 0,100);
  // expression proxy: edgeDensity and central-face-like blobs -> higher
  const expression = clamp(edgeDensity*0.6 + (exaggeration*0.4), 0,100);
  const unexpected = clamp((incongruity*0.6 + (colorFun*0.4)),0,100);
  const overall = clamp((exaggeration*0.18 + colorFun*0.22 + incongruity*0.2 + expression*0.2 + unexpected*0.2),0,100);
  return {exaggeration,colorFun,incongruity,expression,unexpected,overall};
}

// caption suggestions (playful)
function captionSuggestions(stats){
  const base = [];
  if(stats.exaggeration > 40) base.push("When reality took the day off");
  if(stats.colorFun > 50) base.push("Vivid enough to need shades");
  if(stats.incongruity > 50) base.push("I did not sign up for this");
  if(stats.expression > 50) base.push("Mood: dramatically confused");
  if(base.length===0) base.push("That escalated quickly", "Plot twist:");
  return base.slice(0,5);
}
function displaySuggestions(arr){
  // quick prompt to insert suggestion to top text
  const container = document.createElement('div'); container.style.marginTop='8px';
  container.innerHTML = '<div class="small">Caption suggestions</div>';
  arr.forEach(s=>{
    const btn = document.createElement('button'); btn.className='btn2'; btn.style.margin='6px 6px 0 0'; btn.textContent = s;
    btn.onclick = ()=>{ // add as top text or replace selected text
      const sel = layers.find(l=>l.id===selectedId);
      if(sel && sel.type==='text'){ sel.text = s; render(); } else { pushHistory(); layers.push({id:uid(), type:'text', text:s, x:20, y:20, w:400, h:80, size:40, font:'Impact, Arial', color:'#fff', stroke:6, strokeColor:'#000', align:'left', rot:0}); render(); }
    };
    container.appendChild(btn);
  });
  const props = document.querySelector('.props'); props.appendChild(container);
}

// Save as PNG with text/stamps flattened
function exportPNG(){
  return canvas.toDataURL('image/png');
}

// simple project autosave?
function saveStateToLocal(){
  localStorage.setItem('meme_autosave', JSON.stringify(layers.map(l=>{
    const copy = Object.assign({}, l); if(l.type==='image' && l.img){ copy.imgData = canvas.toDataURL(); copy.img = null; } return copy; })));
}
window.addEventListener('beforeunload', saveStateToLocal);

// Load autosave if present
(function loadAuto(){
  try{
    const a = localStorage.getItem('meme_autosave');
    if(a) {
      const project = JSON.parse(a);
      if(project && project.length){ // load images slowly
        (async ()=>{
          for(const pl of project){ if(pl.imgData){ const img = new Image(); await new Promise(r=>{ img.onload=r; img.src=pl.imgData; }); pl.img = img; } layers.push(pl); }
          render();
        })();
      }
    }
  }catch(e){}
})();

// basic utilities
function getMousePos(evt){
  const rect = canvas.getBoundingClientRect();
  return { x: (evt.clientX - rect.left) * (canvas.width/rect.width), y: (evt.clientY - rect.top) * (canvas.height/rect.height) };
}

// initial render
render();

</script>
</body>
</html>
