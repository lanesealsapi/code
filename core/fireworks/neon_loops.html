<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon Swirls & Fireworks</title>
<style>
  html,body {
    height: 100%;
    margin: 0;
    background: #1a1f26; /* darker slate */
    overflow: hidden;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    cursor: crosshair;
  }
  .hint {
    position: fixed;
    left: 14px;
    top: 14px;
    font-family: system-ui, sans-serif;
    font-size: 12px;
    color: rgba(255,255,255,0.7);
    background: rgba(0,0,0,0.2);
    padding: 6px 10px;
    border-radius: 8px;
    backdrop-filter: blur(6px);
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">click/tap for neon swirls & fireworks âœ¨</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  addEventListener('resize', resize, {passive: true});
  resize();

  const particles = [];
  const now = () => performance.now();
  const rand = (a, b) => a + Math.random() * (b - a);

  function randomHue() {
    return Math.floor(rand(0, 360));
  }

  function spawnSwirl(x, y) {
    const hue = randomHue();
    const life = 10000;
    const count = Math.floor(rand(20, 40));
    const spin = rand(-2, 2);

    for (let i = 0; i < count; i++) {
      particles.push({
        type: 'swirl',
        x, y,
        angle: (i / count) * Math.PI * 2,
        radius: rand(20, 80),
        speed: rand(0.05, 0.3),
        spin,
        size: rand(2, 6),
        hue,
        created: now(),
        life,
        phase: rand(0, Math.PI * 2),
        trail: []
      });
    }
  }

  function spawnBurst(x, y) {
    const hue = randomHue();
    const life = 3000;
    const count = Math.floor(rand(40, 80));
    for (let i = 0; i < count; i++) {
      const angle = rand(0, Math.PI * 2);
      const speed = rand(0.1, 0.6);
      particles.push({
        type: 'burst',
        x, y,
        angle,
        speed,
        size: rand(1.5, 4),
        hue,
        created: now(),
        life,
        trail: []
      });
    }
  }

  function spawnRing(x, y) {
    const hue = randomHue();
    const life = 5000;
    const count = Math.floor(rand(30, 60));
    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2;
      particles.push({
        type: 'ring',
        x, y,
        angle,
        radius: 0,
        speed: rand(0.15, 0.4),
        size: rand(2, 5),
        hue,
        created: now(),
        life,
        trail: []
      });
    }
  }

  function handlePointer(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    let x, y;
    if (e.touches && e.touches[0]) {
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    } else {
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    }
    const choice = Math.random();
    if (choice < 0.6) spawnSwirl(x, y);
    else if (choice < 0.85) spawnBurst(x, y);
    else spawnRing(x, y);
  }

  canvas.addEventListener('pointerdown', handlePointer, {passive:false});
  canvas.addEventListener('touchstart', handlePointer, {passive:false});
  canvas.addEventListener('mousedown', handlePointer, {passive:false});

  let last = now();
  function frame() {
    const t = now();
    const dt = t - last;
    last = t;

    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(26,31,38,0.25)';
    ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
    ctx.globalCompositeOperation = 'lighter';

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      const elapsed = t - p.created;
      if (elapsed > p.life) {
        particles.splice(i, 1);
        continue;
      }
      const lifeRatio = elapsed / p.life;
      const alpha = 1 - lifeRatio;

      let nx = p.x, ny = p.y;
      if (p.type === 'swirl') {
        p.angle += p.spin * dt * 0.001;
        p.radius += p.speed * dt;
        const wobble = Math.sin(elapsed * 0.002 + p.phase) * (p.radius * 0.05);
        nx = p.x + Math.cos(p.angle) * (p.radius + wobble);
        ny = p.y + Math.sin(p.angle) * (p.radius + wobble);
      } else if (p.type === 'burst') {
        const dist = p.speed * elapsed;
        nx = p.x + Math.cos(p.angle) * dist;
        ny = p.y + Math.sin(p.angle) * dist;
      } else if (p.type === 'ring') {
        p.radius += p.speed * dt;
        nx = p.x + Math.cos(p.angle) * p.radius;
        ny = p.y + Math.sin(p.angle) * p.radius;
      }

      p.trail.push({x:nx,y:ny});
      if (p.trail.length > 6) p.trail.shift();

      ctx.strokeStyle = `hsla(${p.hue}, 90%, 60%, ${alpha*0.8})`;
      ctx.lineWidth = p.size * 0.6;
      ctx.shadowBlur = 12;
      ctx.shadowColor = `hsla(${p.hue}, 100%, 70%, ${alpha})`;
      if (p.trail.length > 1) {
        ctx.beginPath();
        ctx.moveTo(p.trail[0].x, p.trail[0].y);
        for (let j=1;j<p.trail.length;j++){
          ctx.lineTo(p.trail[j].x, p.trail[j].y);
        }
        ctx.stroke();
      }

      const g = ctx.createRadialGradient(nx, ny, 0, nx, ny, p.size*6);
      g.addColorStop(0, `hsla(${p.hue},100%,70%,${alpha})`);
      g.addColorStop(1, `hsla(${p.hue},100%,50%,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(nx, ny, p.size*3, 0, Math.PI*2);
      ctx.fill();
    }

    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
</body>
</html>
