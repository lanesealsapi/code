<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bricker 9000</title>
  <style>
    body { margin:0; background:#0b0c0f; color:#e9eef2; font-family:sans-serif; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh; }
    canvas { background:#111; display:block; border-radius:12px; max-width:95vw; height:auto; }
    .topbar { display:flex; justify-content:space-between; align-items:center; width:100%; max-width:640px; padding:10px; }
    .score { font-size:18px; color:#fff; }
    .toggle { cursor:pointer; padding:6px 14px; border-radius:20px; background:#333; color:#fff; border:2px solid #888; user-select:none; transition:0.2s; }
    .toggle.active { background:#4ade80; border-color:#22c55e; }
    #preview { position: fixed; bottom: 10px; right: 10px; width: 160px; border-radius: 8px; }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="score" id="score">Score: 0</div>
    <div class="toggle" id="modeToggle">Keyboard</div>
  </div>
  <canvas id="game" width="480" height="576"></canvas>
  <video id="preview" autoplay muted playsinline></video>

  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  <script>
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');
  const video=document.getElementById('preview');
  let facemesh,predictions=[];
  let useFaceControl=false;

  const modeToggle=document.getElementById('modeToggle');
  modeToggle.addEventListener('click',()=>{
    useFaceControl=!useFaceControl;
    modeToggle.classList.toggle('active',useFaceControl);
    modeToggle.textContent=useFaceControl?"Face":"Keyboard";
  });

  let paddleW=160, paddleH=12;
  let paddleX=(canvas.width-paddleW)/2;
  const paddleY=canvas.height-30;

  let ball={x:canvas.width/2,y:canvas.height-40,dx:3,dy:-3,r:8};
  let score=0;

  const brickRowCount=5, brickColumnCount=7;
  const brickWidth=60, brickHeight=18, brickPadding=8;
  const brickOffsetTop=40, brickOffsetLeft=25;
  let bricks=[];

  function initBricks(){
    bricks=[];
    for(let c=0;c<brickColumnCount;c++){
      bricks[c]=[];
      for(let r=0;r<brickRowCount;r++){
        let isMega=(c===Math.floor(brickColumnCount/2)&&r===0);
        bricks[c][r]={x:0,y:0,status:1,mega:isMega};
      }
    }
  }

  function resetGame(){
    initBricks();
    ball={x:canvas.width/2,y:canvas.height-40,dx:3,dy:-3,r:8};
    paddleX=(canvas.width-paddleW)/2;
    score=0;
    document.getElementById('score').textContent="Score: "+score;
  }

  function drawBricks(){
    for(let c=0;c<brickColumnCount;c++){
      for(let r=0;r<brickRowCount;r++){
        let b=bricks[c][r];
        if(b.status==1){
          const brickX=(c*(brickWidth+brickPadding))+brickOffsetLeft;
          const brickY=(r*(brickHeight+brickPadding))+brickOffsetTop;
          b.x=brickX;
          b.y=brickY;
          ctx.fillStyle=b.mega?"#fff":(r%2==0?"#ff40ff":"#40c0ff");
          ctx.globalAlpha=b.mega?1:0.6;
          ctx.fillRect(brickX,brickY,brickWidth,brickHeight);
          ctx.globalAlpha=1;
        }
      }
    }
  }

  function drawPaddle(){
    ctx.fillStyle="#ff40ff";
    ctx.fillRect(paddleX,paddleY,paddleW,paddleH);
  }

  function drawBall(){
    ctx.beginPath();
    ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
    ctx.fillStyle="#60a5fa";
    ctx.fill();
    ctx.closePath();
  }

  function collisionDetection(){
    for(let c=0;c<brickColumnCount;c++){
      for(let r=0;r<brickRowCount;r++){
        let b=bricks[c][r];
        if(b.status==1){
          if(ball.x> b.x && ball.x< b.x+brickWidth && ball.y> b.y && ball.y< b.y+brickHeight){
            ball.dy*=-1;
            b.status=0;
            if(b.mega){
              score+=5;
              resetGame();
              return;
            } else {
              score++;
            }
            document.getElementById('score').textContent="Score: "+score;

            // win condition
            if(score>=brickRowCount*brickColumnCount){
              alert("Game Won!");
              resetGame();
            }
          }
        }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBricks();
    drawPaddle();
    drawBall();
    collisionDetection();

    // move ball
    ball.x+=ball.dx;
    ball.y+=ball.dy;

    if(ball.x+ball.dx<ball.r||ball.x+ball.dx>canvas.width-ball.r){ball.dx*=-1;}
    if(ball.y+ball.dy<ball.r){ball.dy*=-1;}
    else if(ball.y+ball.dy>canvas.height-ball.r){
      if(ball.x>paddleX&&ball.x<paddleX+paddleW){
        let hitPos=(ball.x-(paddleX+paddleW/2))/(paddleW/2);
        ball.dx=hitPos*5;
        ball.dy*=-1;
      } else {
        resetGame();
      }
    }
  }

  function loop(){
    requestAnimationFrame(loop);
    if(useFaceControl) updatePaddleFace();
    draw();
  }

  // keyboard
  document.addEventListener('keydown',e=>{
    if(!useFaceControl){
      if(e.key==='ArrowLeft') paddleX=Math.max(0,paddleX-40);
      if(e.key==='ArrowRight') paddleX=Math.min(canvas.width-paddleW,paddleX+40);
    }
  });

  async function start(){
    const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}});
    video.srcObject=stream;
    await video.play();
    facemesh=ml5.facemesh(video,()=>console.log('Face ready'));
    facemesh.on('predict',res=>predictions=res);
    resetGame();
    loop();
  }

  function updatePaddleFace(){
    if(predictions.length>0){
      const nose=predictions[0].scaledMesh[1];
      const nx=nose[0];
      const norm=1-(nx/video.videoWidth);
      paddleX=norm*(canvas.width-paddleW);
    }
  }

  start();
  </script>
</body>
</html>
