<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gamer Car Game</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
    font-family: sans-serif;
  }

  #gameCanvas {
    display: block;
    background: #222;
  }

  .instructions {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    color: rgba(255,255,255,0.3);
    font-size: 18px;
  }
</style>
</head>
<body>
<div class="instructions">Arrow Up / Space = Jump | Space near obstacle = Fragment | Avoid collisions</div>
<canvas id="gameCanvas" width="800" height="400"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let car = { x: 100, y: 300, width: 80, height: 40, dy: 0, jumping: false };
let obstacles = [];
let fragments = [];
let gravity = 0.8;
let speed = 5;
let jumpPower = -15;

let score = 0;
let health = 3;

// Spawn obstacles every 1.5 seconds
setInterval(() => {
  const height = 80 + Math.random() * 40; // taller obstacles
  obstacles.push({ x: canvas.width, y: 380 - height, width: 50, height: height });
}, 1500);

// Controls
document.addEventListener('keydown', (e) => {
  if (e.code === 'ArrowUp') {
    if (!car.jumping) {
      car.dy = jumpPower;
      car.jumping = true;
    }
  }
  if (e.code === 'Space') {
    // Fragment obstacles in front
    obstacles.forEach((obs, i) => {
      if (obs.x < car.x + car.width + 30 && obs.x > car.x) {
        for (let j = 0; j < 5; j++) {
          fragments.push({
            x: obs.x + 10,
            y: obs.y + 10,
            dx: (Math.random() - 0.5) * 10,
            dy: (Math.random() - 1.5) * 10
          });
        }
        obstacles.splice(i, 1);
        score += 10;
      }
    });
  }
});

// Collision detection helper
function checkCollision(rect1, rect2) {
  return (
    rect1.x < rect2.x + rect2.width &&
    rect1.x + rect1.width > rect2.x &&
    rect1.y < rect2.y + rect2.height &&
    rect1.y + rect1.height > rect2.y
  );
}

// Game loop
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw ground
  ctx.fillStyle = '#333';
  ctx.fillRect(0, 380, canvas.width, 20);

  // Update car
  car.dy += gravity;
  car.y += car.dy;
  if (car.y > 300) {
    car.y = 300;
    car.dy = 0;
    car.jumping = false;
  }

  // Draw car
  ctx.fillStyle = 'cyan';
  ctx.fillRect(car.x, car.y, car.width, car.height);

  // Update obstacles
  ctx.fillStyle = 'red';
  obstacles.forEach((obs, index) => {
    obs.x -= speed;
    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

    // Collision
    if (checkCollision(car, obs)) {
      obstacles.splice(index,1);
      health -= 1;
    }
  });

  // Update fragments
  fragments.forEach((f, i) => {
    f.x += f.dx;
    f.y += f.dy;
    f.dy += 0.5; // gravity
    ctx.fillStyle = 'orange';
    ctx.fillRect(f.x, f.y, 10, 10);
    if (f.y > canvas.height) fragments.splice(i,1);
  });

  // Draw score
  ctx.fillStyle = 'white';
  ctx.font = '20px sans-serif';
  ctx.fillText('Score: ' + score, 10, 30);

  // Draw health bar
  for (let i=0; i<health; i++) {
    ctx.fillStyle = 'lime';
    ctx.fillRect(10 + i*35, 50, 30, 20);
  }

  // Check game over
  if (health <= 0) {
    ctx.fillStyle = 'white';
    ctx.font = '40px sans-serif';
    ctx.fillText('GAME OVER', canvas.width/2 - 120, 200);
    return; // stop loop
  }

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
