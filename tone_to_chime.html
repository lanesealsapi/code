<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sing to Wind Chimes</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background: radial-gradient(circle at center, #222 0%, #000 100%);
      color: #fff;
      overflow: hidden;
      font-family: sans-serif;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin-bottom: 20px;
      cursor: pointer;
      z-index: 2;
      position: relative;
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      border-radius: 6px;
      opacity: 0.5;
    }
    canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <button id="startButton">Enable Mic & Start Chimes</button>
  <canvas id="particleCanvas"></canvas>
  <script>
    const startButton = document.getElementById("startButton");
    const canvas = document.getElementById("particleCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let audioCtx, analyser, dataArray;
    let particles = [];

    // 7 complementary color pair sets
    const colorPairs = [
      ["#4da6ff", "#ffe066"], // blue + yellow
      ["#ff4d4d", "#66ff66"], // red + green
      ["#b366ff", "#ffcc66"], // purple + orange
      ["#66ffff", "#ff6699"], // cyan + pink
      ["#99ff66", "#6666ff"], // lime + indigo
      ["#ff9966", "#66ccff"], // coral + sky blue
      ["#ffff66", "#eeeeee"]  // yellow + gray
    ];

    startButton.addEventListener("click", async () => {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const source = audioCtx.createMediaStreamSource(stream);

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      const bufferLength = analyser.fftSize;
      dataArray = new Float32Array(bufferLength);
      source.connect(analyser);

      detectPitch();
      animateParticles();
    });

    function detectPitch() {
      analyser.getFloatTimeDomainData(dataArray);
      let autoCorr = autoCorrelate(dataArray, audioCtx.sampleRate);
      if (autoCorr !== -1) {
        playChime(autoCorr);
      }
      setTimeout(detectPitch, 400); // detect ~2.5x per second
    }

    function autoCorrelate(buffer, sampleRate) {
      let SIZE = buffer.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) rms += buffer[i] * buffer[i];
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) return -1;

      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE/2; i++) if (Math.abs(buffer[i]) < thres) { r1 = i; break; }
      for (let i = 1; i < SIZE/2; i++) if (Math.abs(buffer[SIZE-i]) < thres) { r2 = SIZE-i; break; }

      buffer = buffer.slice(r1, r2);
      SIZE = buffer.length;

      let c = new Array(SIZE).fill(0);
      for (let i = 0; i < SIZE; i++)
        for (let j = 0; j < SIZE - i; j++)
          c[i] = c[i] + buffer[j] * buffer[j+i];

      let d = 0; while (c[d] > c[d+1]) d++;
      let maxval = -1, maxpos = -1;
      for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
      }
      let T0 = maxpos;
      return sampleRate / T0;
    }

    function playChime(frequency) {
      if (!frequency) return;
      const intervals = [1.25, 1.5, 2.0]; // 3rd, 5th, octave
      const intervalIndex = Math.floor(Math.random() * intervals.length);
      const interval = intervals[intervalIndex];
      const freqs = [frequency, frequency * interval];

      // pick a color pair from 7
      const pair = colorPairs[intervalIndex % colorPairs.length];

      freqs.forEach((f, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = "sine";
        osc.frequency.value = f;

        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.0);

        osc.connect(gainNode).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 1.0);

        // spawn particles for this note with its color
        spawnParticles(pair[i % 2]);
      });
    }

    function spawnParticles(color) {
      for (let i = 0; i < 15; i++) {
        particles.push({
          x: canvas.width/2,
          y: canvas.height/2,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          size: Math.random() * 4 + 2,
          life: 60,
          color: color
        });
      }
    }

    function animateParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      particles.forEach((p, idx) => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(idx, 1);
      });
      requestAnimationFrame(animateParticles);
    }
  </script>
</body>
</html>
