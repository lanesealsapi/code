<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Particle Shape Shifter — v1.1</title>
  <style>
    :root{--bg:#0a0b0f;--accent:#7ad3ff;--muted:#9aa3b2}
    html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:Inter,ui-sans-serif,system-ui,Arial}
    #app{height:100vh;display:grid;grid-template-rows:1fr auto}
    canvas{display:block;width:100%;height:100%}
    .ui{display:flex;align-items:center;gap:12px;padding:10px 14px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);backdrop-filter:blur(6px)}
    .legend{display:flex;gap:10px;align-items:center;flex-wrap:wrap;font-size:13px;color:var(--muted)}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
    .title{font-weight:600;color:#fff}
    .shape-name{margin-left:auto;font-weight:600;color:var(--accent)}
    .hint{font-size:12px;color:var(--muted)}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 8px;border-radius:8px;cursor:pointer}
  </style>
</head>
<body>
  <div id="app">
    <canvas id="c"></canvas>
    <div class="ui">
      <div class="title">Particle Shape Shifter — v1.1</div>
      <div class="legend pill">Move mouse <strong>left → right</strong> to morph shapes</div>
      <div class="legend">Shapes (easy → complex):
        <span class="pill">Circle</span>
        <span class="pill">Triangle</span>
        <span class="pill">Square</span>
        <span class="pill">Pentagon</span>
        <span class="pill">Star</span>
        <span class="pill">Heart</span>
        <span class="pill">Spiral</span>
        <span class="pill">Blob</span>
      </div>
      <div class="shape-name" id="shapeLabel">Circle</div>
      <button id="randJitter">Randomize</button>
      <div class="hint">Click canvas to reset particle positions</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * DPR);
    canvas.height = Math.floor(canvas.clientHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Settings
  const PARTICLES = 900; // total particles (kept equal to POINTS_PER_SHAPE for 1:1 mapping)
  const POINTS_PER_SHAPE = 900; // sample count per shape
  const shapes = [];
  const shapeNames = ['Circle','Triangle','Square','Pentagon','Star','Heart','Spiral','Blob'];

  // Helpers
  function p2(x,y){return {x,y}};
  function lerp(a,b,t){return a + (b-a)*t}

  // Normalize set of points to center around 0 and max radius 1
  function normalizePoints(pts){
    let cx=0, cy=0; for(const p of pts){cx+=p.x; cy+=p.y;} cx/=pts.length; cy/=pts.length;
    let maxr=0; for(const p of pts){p.x-=cx; p.y-=cy; maxr=Math.max(maxr, Math.hypot(p.x,p.y));}
    if(maxr===0) maxr=1; for(const p of pts){p.x/=maxr; p.y/=maxr;}
  }

  // Sample a polygon's perimeter evenly
  function samplePolygonPerimeter(verts, n){
    // compute edges and lengths
    const edges = []; let perim=0;
    for(let i=0;i<verts.length;i++){ const a=verts[i]; const b=verts[(i+1)%verts.length]; const len=Math.hypot(b.x-a.x, b.y-a.y); edges.push({a,b,len}); perim+=len; }
    const pts=[];
    for(let i=0;i<n;i++){
      let dist = (i / n) * perim;
      let acc=0, ei=0;
      while(ei < edges.length && acc + edges[ei].len < dist){ acc += edges[ei].len; ei++; }
      const edge = edges[ei % edges.length];
      const local = edge.len === 0 ? 0 : (dist - acc) / edge.len;
      const x = edge.a.x + (edge.b.x - edge.a.x) * local;
      const y = edge.a.y + (edge.b.y - edge.a.y) * local;
      pts.push(p2(x,y));
    }
    return pts;
  }

  // Shape generators
  function generateCircle(n){
    const pts=[]; for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; pts.push(p2(Math.cos(a), Math.sin(a))); } return pts;
  }

  function generateRegularPolygon(nSides, n){
    // vertices on unit circle
    const verts=[]; for(let k=0;k<nSides;k++){ const a=(k/nSides)*Math.PI*2; verts.push({x:Math.cos(a), y:Math.sin(a)}); }
    const sampled = samplePolygonPerimeter(verts, n);
    normalizePoints(sampled);
    return sampled;
  }

  function generateStar(n, points=5){
    // construct star polygon vertices (alternating outer/inner)
    const verts=[]; const spikes = points*2; const innerR = 0.45;
    for(let k=0;k<spikes;k++){ const r = (k%2===0)?1:innerR; const a=(k/spikes)*Math.PI*2; verts.push({x:Math.cos(a)*r, y:Math.sin(a)*r}); }
    const sampled = samplePolygonPerimeter(verts, n);
    normalizePoints(sampled);
    return sampled;
  }

  function generateHeart(n){
    const pts=[]; for(let i=0;i<n;i++){ const t = (i/n) * Math.PI*2; // parametric
      const x = 16*Math.pow(Math.sin(t),3);
      const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
      pts.push(p2(x,-y)); }
    normalizePoints(pts); return pts;
  }

  function generateSpiral(n){
    const pts=[]; for(let i=0;i<n;i++){ const t = i/n * 6 * Math.PI; const r = 0.02 + (i/n)*0.98; pts.push(p2(Math.cos(t)*r, Math.sin(t)*r)); } normalizePoints(pts); return pts;
  }

  function generateBlob(n){
    const pts=[]; for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; const r = 0.7 + 0.18*Math.sin(a*6 + i*0.01) + 0.12*Math.cos(a*3 + i*0.02); pts.push(p2(Math.cos(a)*r, Math.sin(a)*r)); } normalizePoints(pts); return pts;
  }

  // Build shapes — ensure we have robust sampling for polygons and stars
  shapes.push(generateCircle(POINTS_PER_SHAPE));
  shapes.push(generateRegularPolygon(3, POINTS_PER_SHAPE));
  shapes.push(generateRegularPolygon(4, POINTS_PER_SHAPE));
  shapes.push(generateRegularPolygon(5, POINTS_PER_SHAPE));
  shapes.push(generateStar(POINTS_PER_SHAPE, 5));
  shapes.push(generateHeart(POINTS_PER_SHAPE));
  shapes.push(generateSpiral(POINTS_PER_SHAPE));
  shapes.push(generateBlob(POINTS_PER_SHAPE));

  // Particle system
  const particles = new Array(PARTICLES);
  for(let i=0;i<PARTICLES;i++){
    particles[i] = { x: (Math.random()-0.5)*200, y: (Math.random()-0.5)*200, vx:0, vy:0, id:i, jitterOffset: Math.random()*10000 };
  }

  // Interaction
  let mouseX = canvas.clientWidth/2; let norm=0;
  canvas.addEventListener('pointermove', (e)=>{ const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; norm = Math.min(1, Math.max(0, mouseX / rect.width)); });
  canvas.addEventListener('pointerdown', ()=>{ for(const p of particles){ p.x=(Math.random()-0.5)*200; p.y=(Math.random()-0.5)*200; p.vx=0;p.vy=0; } });
  document.getElementById('randJitter').addEventListener('click', ()=>{ for(const p of particles){ p.jitterOffset = Math.random()*10000 } });

  // Map particle index to shape sample point
  function getShapePoint(shapeIndex, idx){
    const N = shapes.length;
    const flo = Math.floor(shapeIndex);
    const cei = Math.min(N-1, Math.ceil(shapeIndex));
    const t = shapeIndex - flo;
    // ensure we wrap sampling index proportionally to array length
    const sA = shapes[flo];
    const sB = shapes[cei];
    const j = Math.floor((idx / PARTICLES) * POINTS_PER_SHAPE) % POINTS_PER_SHAPE;
    const a = sA[j]; const b = sB[j];
    return { x: lerp(a.x, b.x, t), y: lerp(a.y, b.y, t) };
  }

  // animation
  let last = performance.now();
  function step(now){
    const dt = Math.min(40, now-last); last = now;
    const shapeIndex = norm * (shapes.length - 1);
    const primaryIdx = Math.round(shapeIndex);
    document.getElementById('shapeLabel').textContent = shapeNames[primaryIdx];

    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
    const scale = Math.min(canvas.clientWidth, canvas.clientHeight) * 0.36;

    for(let i=0;i<PARTICLES;i++){
      const p = particles[i];
      const pi = getShapePoint(shapeIndex, i);
      const targetX = cx + pi.x * scale;
      const targetY = cy + pi.y * scale;

      const ttime = now*0.001;
      const jitterStrength = 8 * (0.6 + 0.4*Math.sin(i*0.1 + ttime*2));
      const jx = Math.sin(ttime*2 + p.jitterOffset*0.001 + i*0.03) * 0.5 + Math.cos(ttime*1.3 + i*0.02)*0.5;
      const jy = Math.cos(ttime*1.7 + p.jitterOffset*0.001 + i*0.05);
      const tx = targetX + jx * jitterStrength;
      const ty = targetY + jy * jitterStrength;

      const stiffness = 0.08; const damping = 0.82;
      p.vx += (tx - p.x) * stiffness; p.vy += (ty - p.y) * stiffness;
      p.vx *= damping; p.vy *= damping;
      p.x += p.vx * (dt/16); p.y += p.vy * (dt/16);

      const sz = 1.6 + 1.4*Math.abs(Math.sin(i*0.1 + now*0.002));
      ctx.beginPath(); ctx.fillStyle = 'rgba(211,40,40,0.95)'; ctx.moveTo(p.x+sz, p.y); ctx.arc(p.x, p.y, sz, 0, Math.PI*2); ctx.fill();
    }

    requestAnimationFrame(step);
  }

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
