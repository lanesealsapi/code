<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Abstract Rorschach Artwork Generator — Standalone</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#8b5cf6;--muted:#94a3b8;--glass: rgba(255,255,255,0.04)}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,var(--bg),#071027);color:#e6eef8;display:flex;align-items:stretch}
    .app{display:grid;grid-template-columns:340px 1fr;gap:16px;padding:16px;width:100%;height:100vh;box-sizing:border-box}
    .panel{background:var(--panel);border-radius:12px;padding:14px;box-shadow:0 6px 20px rgba(2,6,23,0.6);overflow:auto}
    h1{font-size:16px;margin:0 0 8px 0}
    label{display:block;font-size:12px;color:var(--muted);margin-top:10px}
    .row{display:flex;gap:8px;align-items:center}
    input[type=range]{width:100%}
    input[type=color]{height:34px;width:46px;border-radius:6px;border:none}
    .controls{display:flex;flex-direction:column}
    button,select{background:linear-gradient(180deg,#162336,#0f1a2a);color:#e6eef8;border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;cursor:pointer}
    .small{font-size:12px;padding:6px 8px}
    canvas{display:block;width:100%;height:100%;border-radius:12px;background:linear-gradient(180deg,#061021,#0b1320);box-shadow:inset 0 0 120px rgba(0,0,0,0.45)}
    .topbar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px}
    .footer{margin-top:12px;color:var(--muted);font-size:12px}
    .group{margin-top:6px;padding:8px;background:var(--glass);border-radius:8px}
    .flex{display:flex;gap:8px;align-items:center}
    .big{font-size:13px}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <div class="topbar">
        <div>
          <h1>Abstract Rorschach — Generator</h1>
          <div style="font-size:12px;color:var(--muted)">Standalone HTML — tweak knobs, export PNG</div>
        </div>
        <div class="flex">
          <button id="randomize" class="small">Randomize</button>
          <button id="export" class="small">Export PNG</button>
        </div>
      </div>

      <div class="controls">
        <label class="big">Seed (text)</label>
        <input id="seedText" type="text" placeholder="leave blank for random" style="padding:8px;border-radius:8px;border:none;background:#061323;color:#e6eef8" />

        <label>Mirror symmetry</label>
        <div class="row">
          <select id="mirrorMode">
            <option value="vertical">Vertical (Rorschach)</option>
            <option value="radial">Radial / kaleidoscope</option>
            <option value="none">None (free)</option>
          </select>
          <input id="symmetryCount" type="number" min="2" max="12" value="2" style="width:64px;padding:6px;border-radius:6px;background:#061323;border:none;color:#e6eef8" />
        </div>

        <div class="group">
          <label>Blob count: <span id="blobCountLabel">12</span></label>
          <input id="blobCount" type="range" min="1" max="120" value="12" />

          <label>Brush size: <span id="brushLabel">42</span></label>
          <input id="brushSize" type="range" min="2" max="200" value="42" />

          <label>Ink density (opacity): <span id="densityLabel">0.85</span></label>
          <input id="density" type="range" min="0.02" max="1" step="0.01" value="0.85" />

          <label>Chaos / spread: <span id="chaosLabel">0.45</span></label>
          <input id="chaos" type="range" min="0" max="2" step="0.01" value="0.45" />
        </div>

        <div class="group">
          <label>Color palette (pick up to 5)</label>
          <div id="paletteInputs" class="row">
            <input class="paletteColor" type="color" value="#0ea5a4" />
            <input class="paletteColor" type="color" value="#60a5fa" />
            <input class="paletteColor" type="color" value="#a78bfa" />
            <input class="paletteColor" type="color" value="#fb7185" />
            <input class="paletteColor" type="color" value="#fbbf24" />
          </div>
          <div style="margin-top:8px" class="row">
            <button id="muted" class="small">Muted</button>
            <button id="neon" class="small">Neon</button>
            <button id="monochrome" class="small">Monochrome</button>
          </div>
        </div>

        <div class="group">
          <label>Rendering</label>
          <div class="row">
            <label class="flex"><input id="blendMode" type="checkbox" checked /> Use additive blending</label>
            <label class="flex"><input id="antialias" type="checkbox" checked /> Smooth strokes</label>
          </div>

          <label class="flex"><input id="animate" type="checkbox" /> Continuous morph</label>
          <label class="flex"><input id="drip" type="checkbox" /> Allow drips (gravity)</label>
          <label class="flex"><input id="mirrorFade" type="checkbox" checked /> Mirror fade symmetry edges</label>
        </div>

        <div class="group">
          <label>Advanced</label>
          <label class="flex">Blob complexity: <input id="complexity" type="range" min="0" max="1" step="0.01" value="0.6" style="width:160px;margin-left:8px" /></label>
          <label class="flex">Seed jitter: <input id="jitter" type="range" min="0" max="1" step="0.01" value="0.2" style="width:160px;margin-left:8px" /></label>
        </div>

        <div class="footer">Tip: change symmetry mode to <strong>radial</strong> and increase symmetry count for kaleidoscope effects. Use export to save a PNG.</div>
      </div>
    </div>

    <div style="display:flex;flex-direction:column;gap:12px;">
      <div style="flex:1;min-height:0;border-radius:12px;overflow:hidden;position:relative">
        <canvas id="art" width="1600" height="1200"></canvas>
      </div>
      <div style="display:flex;gap:8px;align-items:center;justify-content:flex-end">
        <div style="color:var(--muted);font-size:12px">Canvas size:</div>
        <select id="sizePreset" class="small">
          <option value="1600x1200">1600 × 1200</option>
          <option value="1200x1600">1200 × 1600 (tall)</option>
          <option value="1024x1024">1024 × 1024 (square)</option>
          <option value="2048x1536">2048 × 1536 (hi-res)</option>
        </select>
      </div>
    </div>
  </div>

  <script>
  // Standalone abstract Rorschach generator
  // Deterministic RNG from string seed
  function xfnv1a(str) {
    for(var i=0,h=2166136261>>>0;i<str.length;i++){
      h=Math.imul(h^str.charCodeAt(i),16777619)|0;
    }
    return function() {
      h=Math.imul(h^ (h>>>16),2246822507);
      h=Math.imul(h^ (h>>>13),3266489909);
      return (h ^= h>>>16) >>> 0;
    }
  }
  function mulberry32(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  const canvas = document.getElementById('art');
  const ctx = canvas.getContext('2d', {alpha:true, desynchronized:true});

  // UI elements
  const seedText = document.getElementById('seedText');
  const blobCount = document.getElementById('blobCount');
  const blobCountLabel = document.getElementById('blobCountLabel');
  const brushSize = document.getElementById('brushSize');
  const brushLabel = document.getElementById('brushLabel');
  const density = document.getElementById('density');
  const densityLabel = document.getElementById('densityLabel');
  const chaos = document.getElementById('chaos');
  const chaosLabel = document.getElementById('chaosLabel');
  const paletteColors = Array.from(document.querySelectorAll('.paletteColor'));
  const randomizeBtn = document.getElementById('randomize');
  const exportBtn = document.getElementById('export');
  const mirrorMode = document.getElementById('mirrorMode');
  const symmetryCount = document.getElementById('symmetryCount');
  const blendMode = document.getElementById('blendMode');
  const antialias = document.getElementById('antialias');
  const animate = document.getElementById('animate');
  const drip = document.getElementById('drip');
  const mirrorFade = document.getElementById('mirrorFade');
  const complexity = document.getElementById('complexity');
  const jitter = document.getElementById('jitter');
  const sizePreset = document.getElementById('sizePreset');

  // labels
  function updateLabels(){ blobCountLabel.textContent = blobCount.value; brushLabel.textContent = brushSize.value; densityLabel.textContent = Number(density.value).toFixed(2); chaosLabel.textContent = Number(chaos.value).toFixed(2); }
  [blobCount,brushSize,density,chaos].forEach(el=>el.addEventListener('input',updateLabels));
  updateLabels();

  function setCanvasSizeFromPreset(){ const [w,h]=sizePreset.value.split('x').map(Number); canvas.width=w; canvas.height=h; drawFull(); }
  sizePreset.addEventListener('change',setCanvasSizeFromPreset);

  // seed and RNG
  function makeRNGFromSeed(seedStr){ if(!seedStr) seedStr = String(Date.now()) + Math.random().toString(36).slice(2); const h = xfnv1a(seedStr)(); return mulberry32(h); }

  function pickPalette(rng){ return paletteColors.map(c=>c.value).filter(Boolean); }

  function clearCanvas(){ ctx.clearRect(0,0,canvas.width,canvas.height); // fill subtle paper
    ctx.fillStyle = '#05070a'; ctx.globalCompositeOperation='source-over'; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function drawFull(){ // main renderer
    clearCanvas();
    const seed = seedText.value || Math.random().toString(36).slice(2);
    const rng = makeRNGFromSeed(seed + Math.round(Math.random()*100000*jitter.value));

    ctx.imageSmoothingEnabled = antialias.checked;
    ctx.globalCompositeOperation = blendMode.checked ? 'lighter' : 'source-over';

    const count = +blobCount.value;
    const brush = +brushSize.value;
    const dens = +density.value;
    const ch = +chaos.value;
    const pal = pickPalette(rng);
    const mode = mirrorMode.value;
    const sym = Math.max(2,Math.min(12, +symmetryCount.value));
    const comp = +complexity.value;
    const allowDrip = drip.checked;

    // center reference
    const cx = canvas.width/2, cy = canvas.height/2;

    // draw multiple blobs
    for(let i=0;i<count;i++){
      const color = pal[Math.floor(rng()*pal.length)];
      const size = Math.max(2, Math.round(brush * (0.6 + rng()*1.6)));
      const angle = rng()*Math.PI*2;
      // random origin biased to center
      const r = Math.pow(rng(), 1+ch*0.7) * Math.min(canvas.width,canvas.height)*0.28;
      const ox = cx + Math.cos(angle)*r*(0.2 + rng()*0.9);
      const oy = cy + Math.sin(angle)*r*(0.2 + rng()*0.9);

      drawBlob({x:ox,y:oy,size,color,rng,alpha:dens,complexity:comp,allowDrip,mode,symmetry:sym});
    }

    if(mirrorFade.checked && mode!=='none') applyMirrorFade();
  }

  function drawBlob({x,y,size,color,rng,alpha,complexity,allowDrip,mode,symmetry}){
    // create an offscreen canvas for layering
    const off = document.createElement('canvas'); off.width = size*4; off.height = size*4; const octx = off.getContext('2d');
    octx.clearRect(0,0,off.width,off.height);
    octx.translate(off.width/2, off.height/2);

    // radial path with noise
    const steps = 18 + Math.floor(complexity*40);
    const path = new Path2D();
    for(let s=0;s<steps;s++){
      const t = s/steps;
      const a = t * Math.PI*2;
      const radius = size * (0.4 + 0.6*Math.pow(rng(), 1.6)) * (1 + 0.6*(Math.sin(a*6 + rng()*6)));
      const px = Math.cos(a)*radius*(1 + (rng()-0.5)*0.8);
      const py = Math.sin(a)*radius*(1 + (rng()-0.5)*0.8);
      if(s===0) path.moveTo(px,py); else path.lineTo(px,py);
    }
    path.closePath();

    // blur and shadow-like effect via multiple concentric fills
    for(let layer=0;layer<4;layer++){
      const a = alpha * (1 - layer*0.18);
      octx.globalAlpha = Math.max(0.02,a);
      // create gradient tint
      const g = octx.createRadialGradient(0,0,size*0.1,0,0,size*1.2);
      g.addColorStop(0, color);
      g.addColorStop(1, hexToRgba(color,0));
      octx.fillStyle = g;
      octx.fill(path);
      // small smudge
      octx.globalCompositeOperation = 'multiply';
      octx.fill(path);
      octx.globalCompositeOperation = 'source-over';
    }

    // optional drips: draw narrow elongated blobs
    if(allowDrip && rng() < 0.3){
      const dripCount = 1 + Math.floor(rng()*3);
      for(let d=0;d<dripCount;d++){
        const dx = (rng()-0.5)*size*0.6;
        const dy = size*(0.6 + rng()*3);
        octx.beginPath(); octx.moveTo(dx, size*0.6); octx.quadraticCurveTo(dx+Math.sin(rng()*6)*10, size*1.1, dx, dy); octx.lineWidth = Math.max(2, size*0.08); octx.strokeStyle = color; octx.globalAlpha = alpha*0.9; octx.stroke();
      }
    }

    // render offscreen to main canvas with symmetry
    if(mode === 'none'){
      ctx.save(); ctx.globalAlpha = 1; ctx.drawImage(off, x-off.width/2, y-off.height/2); ctx.restore();
    } else if(mode === 'vertical'){
      // draw on left then mirror on right
      ctx.save(); ctx.globalAlpha = 1; ctx.drawImage(off, x-off.width/2, y-off.height/2);
      ctx.scale(-1,1);
      const mx = -canvas.width + (canvas.width - x) - off.width/2; // convert x to mirrored
      ctx.drawImage(off, mx, y-off.height/2);
      ctx.restore();
    } else if(mode === 'radial'){
      // draw rotated copies around center
      const cx = canvas.width/2, cy = canvas.height/2;
      for(let i=0;i<symmetry;i++){
        const a = (i/symmetry) * Math.PI*2;
        ctx.save(); ctx.translate(cx,cy); ctx.rotate(a); ctx.globalAlpha = 1; ctx.drawImage(off, x-cx-off.width/2, y-cy-off.height/2); ctx.restore();
      }
    }
  }

  function applyMirrorFade(){ // soften seam where mirror meets
    const w = canvas.width, h = canvas.height;
    const grad = ctx.createLinearGradient(w/2 - 60,0,w/2 + 60,0);
    grad.addColorStop(0,'rgba(0,0,0,0)'); grad.addColorStop(0.5,'rgba(0,0,0,0.06)'); grad.addColorStop(1,'rgba(0,0,0,0)');
    ctx.save(); ctx.globalCompositeOperation = 'destination-over'; ctx.fillStyle = grad; ctx.fillRect(0,0,w,h); ctx.restore();
  }

  function hexToRgba(hex,a){ if(!hex) return 'rgba(0,0,0,'+a+')'; const r=parseInt(hex.slice(1,3),16);const g=parseInt(hex.slice(3,5),16);const b=parseInt(hex.slice(5,7),16);return `rgba(${r},${g},${b},${a})`; }

  // UI hookups
  function readAndDraw(){ // don't reroll seed unless user changed it intentionally
    drawFull();
  }

  document.querySelectorAll('input,select').forEach(el=>{ el.addEventListener('input', ()=>{ if(el.id==='seedText') return; if(!animate.checked) readAndDraw(); }); });

  randomizeBtn.addEventListener('click', ()=>{ // randomize parameters
    seedText.value = Math.random().toString(36).slice(2,10);
    blobCount.value = 8 + Math.floor(Math.random()*80);
    brushSize.value = 16 + Math.floor(Math.random()*160);
    density.value = (0.3 + Math.random()*0.7).toFixed(2);
    chaos.value = (Math.random()*1.6).toFixed(2);
    symmetryCount.value = 2 + Math.floor(Math.random()*10);
    // random palette
    paletteColors.forEach((c,i)=>{ c.value = randomPaletteColor(i); });
    updateLabels(); readAndDraw();
  });

  function randomPaletteColor(i){ // generate pleasing-ish colors
    const hues = [200,210,260,340,45,160,280,30];
    const h = hues[Math.floor(Math.random()*hues.length)];
    const s = 60 + Math.floor(Math.random()*30);
    const l = 45 + Math.floor(Math.random()*20);
    return hslToHex(h,s,l);
  }

  function hslToHex(h,s,l){ s/=100; l/=100; const k=(n)=>{ const a=s*Math.min(l,1-l); const f=(n)=>{ const k2=(n+ h/30)%12; const c = l - a*Math.max(Math.min(k2-3,9-k2,1),-1); return Math.round(255*c); }; return [f(0),f(8),f(4)]; }; const rgb=k(); return '#'+rgb.map(x=>x.toString(16).padStart(2,'0')).join(''); }

  exportBtn.addEventListener('click', ()=>{
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = `rorschach-${(seedText.value||'random').slice(0,10)}.png`; a.click();
  });

  // palette presets
  document.getElementById('muted').addEventListener('click', ()=>{
    const p = ['#7f8c8d','#95a5a6','#b0b6b9','#9aa0a6','#8f9aa3']; paletteColors.forEach((c,i)=>c.value=p[i%p.length]); if(!animate.checked) drawFull();
  });
  document.getElementById('neon').addEventListener('click', ()=>{ const p=['#06b6d4','#60a5fa','#8b5cf6','#fb7185','#f59e0b']; paletteColors.forEach((c,i)=>c.value=p[i%p.length]); if(!animate.checked) drawFull(); });
  document.getElementById('monochrome').addEventListener('click', ()=>{ const base='#101827'; paletteColors.forEach((c,i)=>{ c.value = shade(base, -8*i); }); if(!animate.checked) drawFull(); });

  function shade(hex, percent){ const f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=Math.abs(percent)/100; const R=f>>16,G=(f>>8)&0x00FF,B=f&0x0000FF; return '#'+(0x1000000 + (Math.round((t-R)*p)+R)*0x10000 + (Math.round((t-G)*p)+G)*0x100 + (Math.round((t-B)*p)+B)).toString(16).slice(1); }

  // animation loop
  let animHandle=null; function animLoop(){ if(!animate.checked) return; // update jittering seed to morph
    // slightly vary a few parameters and redraw
    const oldSeed = seedText.value || '';
    // mutate seed subtly by appending small time-based value
    seedText.value = (oldSeed || 'morph') + Math.floor(performance.now()/500).toString(36);
    drawFull(); animHandle = requestAnimationFrame(animLoop);
  }

  animate.addEventListener('change', ()=>{ if(animate.checked){ animLoop(); } else { if(animHandle) cancelAnimationFrame(animHandle); drawFull(); } });

  // initial draw
  setCanvasSizeFromPreset();
  // draw once after load
  window.addEventListener('load', ()=>{ if(!animate.checked) drawFull(); });

  // utility: change palette inputs causes redraw
  paletteColors.forEach(c=>c.addEventListener('input', ()=>{ if(!animate.checked) drawFull(); }));

  // small UX: clicking canvas will place a fresh blob at mouse
  canvas.addEventListener('click', (ev)=>{
    const rect = canvas.getBoundingClientRect(); const x = (ev.clientX - rect.left) * (canvas.width/rect.width); const y = (ev.clientY - rect.top) * (canvas.height/rect.height);
    const rng = makeRNGFromSeed((seedText.value||'click') + Math.random().toString(36).slice(2));
    drawBlob({x,y,size:+brushSize.value,color:paletteColors[Math.floor(rng()*paletteColors.length)].value,rng,alpha:+density.value,complexity:+complexity.value,allowDrip:drip.checked,mode:mirrorMode.value,symmetry:+symmetryCount.value});
    if(mirrorFade.checked && mirrorMode.value!=='none') applyMirrorFade();
  });

  // small helpers
  function drawOnce(){ drawFull(); }

  // initial randomize for an interesting start
  randomizeBtn.click();
  </script>
</body>
</html>
