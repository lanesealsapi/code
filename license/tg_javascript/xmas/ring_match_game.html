<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Concentric Ring Alignment Game</title>
<style>
  html, body {margin:0; padding:0; height:100%; display:flex; justify-content:center; align-items:center; background:#111; color:#fff; font-family:sans-serif;}
  canvas {background:#111; border-radius:12px;}
  #hud {position:absolute; top:20px; font-size:20px;}
</style>
</head>
<body>
<div id="hud">Time left: <span id="timer">10</span>s</div>
<canvas id="gameCanvas" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const timerEl = document.getElementById('timer');

const CENTER_X = canvas.width/2;
const CENTER_Y = canvas.height/2;
const TOTAL_RINGS = 3;
const GAP_SIZE = Math.PI/6; // 30 degrees
const RADIUS_STEP = 60;
let rings = [];
let mouse = {x:0,y:0,down:false};
let startTime = null;
let timeLimit = 10; // seconds

function initLevel(){
    rings = [];
    for(let i=0;i<TOTAL_RINGS;i++){
        let gapStart = Math.random()*Math.PI*2;
        rings.push({
            radius: 80 + i*RADIUS_STEP,
            rotation: 0,
            gapStart: gapStart,
            gapSize: GAP_SIZE,
            rotating:false
        });
    }
    startTime = Date.now();
}

canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});
canvas.addEventListener('mousedown', ()=>{ mouse.down=true; });
canvas.addEventListener('mouseup', ()=>{ mouse.down=false; });

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let i=0;i<rings.length;i++){
        let r = rings[i];
        ctx.beginPath();
        ctx.arc(CENTER_X,CENTER_Y,r.radius,0,Math.PI*2);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 20;
        ctx.stroke();
        // draw gap
        ctx.beginPath();
        ctx.arc(CENTER_X,CENTER_Y,r.radius,r.gapStart+r.rotation,r.gapStart+r.rotation+r.gapSize);
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 20;
        ctx.stroke();
    }
}

function update(){
    // rotate ring if mouse over it and mouse down
    rings.forEach(r=>{
        const dx = mouse.x - CENTER_X;
        const dy = mouse.y - CENTER_Y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if(mouse.down && dist > r.radius-10 && dist < r.radius+10){
            r.rotation += 0.02;
        }
    });

    // check alignment: all gaps line up within small threshold
    if(rings.length>0){
        const firstGap = (rings[0].gapStart + rings[0].rotation)%(Math.PI*2);
        let aligned = rings.every(r => Math.abs((r.gapStart+r.rotation)% (Math.PI*2) - firstGap) < 0.05);
        if(aligned){
            rings.pop();
            if(rings.length>0){
                // continue game
            } else {
                alert('Level cleared!');
                initLevel();
            }
        }
    }

    // update timer
    const elapsed = (Date.now()-startTime)/1000;
    const timeLeft = Math.max(0,(timeLimit - elapsed).toFixed(1));
    timerEl.textContent = timeLeft;
    if(timeLeft <= 0){
        alert('Time up! Try again.');
        initLevel();
    }
}

function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}

initLevel();
loop();
</script>
</body>
</html>
