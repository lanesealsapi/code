<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Burst Particle Emitter with BPM</title>
<style>
  body { margin:0; overflow:hidden; background:#111; color:white; font-family:sans-serif; display:flex; flex-direction:column; align-items:center; justify-content:center; }
  canvas { display:block; margin-top:10px; }
  input, label { margin-top:10px; }
</style>
</head>
<body>

<h2>Upload Image for 3D Burst Particle Emitter</h2>
<input type="file" id="upload" accept="image/*">
<label for="bpm">Burst BPM: <span id="bpmDisplay">12</span></label>
<input type="range" id="bpm" min="1" max="120" value="12">

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let particles = [];
let bpm = 12;               // bursts per minute
let cycleTime = 60 / bpm;   // seconds per cycle
let startTime = null;
let imgLoaded = false;

// update BPM dynamically
const bpmSlider = document.getElementById('bpm');
const bpmDisplay = document.getElementById('bpmDisplay');
bpmSlider.addEventListener('input', e => {
    bpm = parseInt(e.target.value);
    bpmDisplay.textContent = bpm;
    cycleTime = 60 / bpm;
});

class Particle {
    constructor(x, y, color) {
        this.originX = x;
        this.originY = y;
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 200 + 50;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.z = Math.random();
        this.zOffset = 0;
    }
    update(t) {
        const eased = Math.sin(t * Math.PI);
        const burst = Math.sin(t * Math.PI) * 100 * this.z;
        this.zOffset = burst;
        this.x = this.originX + this.vx * eased * this.z;
        this.y = this.originY + this.vy * eased * this.z;
        this.size = 1 + this.z * 3 + this.zOffset * 0.02;
        this.alpha = 0.3 + this.z * 0.7 + this.zOffset * 0.002;
    }
    draw() {
        ctx.fillStyle = `rgba(${this.color[0]},${this.color[1]},${this.color[2]},${Math.min(this.alpha,1)})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

function animate(timestamp) {
    if (!startTime) startTime = timestamp;
    const elapsed = (timestamp - startTime) / 1000;
    const t = (elapsed % cycleTime) / cycleTime;

    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (imgLoaded) {
        particles.forEach(p => {
            p.update(t < 0.5 ? t*2 : 2 - t*2);
            p.draw();
        });
    }

    requestAnimationFrame(animate);
}

function createParticlesFromImage(img) {
    const tempCanvas = document.createElement('canvas');
    const tctx = tempCanvas.getContext('2d');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    tctx.drawImage(img, 0, 0);

    const imgData = tctx.getImageData(0, 0, img.width, img.height).data;
    particles = [];
    for (let y = 0; y < img.height; y += 4) {
        for (let x = 0; x < img.width; x += 4) {
            const index = (y * img.width + x) * 4;
            const color = [imgData[index],imgData[index+1],imgData[index+2]];
            const px = canvas.width/2 - img.width/2 + x;
            const py = canvas.height/2 - img.height/2 + y;
            particles.push(new Particle(px, py, color));
        }
    }
    imgLoaded = true;
}

document.getElementById('upload').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = event => {
        const img = new Image();
        img.onload = () => createParticlesFromImage(img);
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
});

animate();
</script>

</body>
</html>
