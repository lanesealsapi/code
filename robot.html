<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>SVG Robotic Hand — Waving</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#0b0b10;--panel:rgba(255,255,255,0.06);--accent:#9fb8ff;--metal1:#b7c4d9;--metal2:#6f7890}
  html,body{height:100%;margin:0;background:var(--bg);color:#eef;font-family:system-ui,Segoe UI,Roboto}
  .wrap{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden}
  .ui{position:absolute;left:12px;top:12px;backdrop-filter:blur(6px);background:var(--panel);padding:8px;border-radius:8px;font-size:13px}
  .ui label{display:block;margin:6px 0}
  svg{width:min(92vw,1200px);height:auto;display:block}
  /* make pointer cursor and touch friendly */
  .draggable{cursor:grab;touch-action:none}
  .hint{font-size:12px;opacity:.8;margin-top:6px}
  /* subtle highlight for moving parts when toggled off */
  .muted{opacity:.6;filter:grayscale(.2)}
</style>
</head>
<body>
<div class="wrap">
  <div class="ui" aria-hidden="true">
    <label>Speed: <input id="speed" type="range" min="0" max="3" step="0.01" value="1"></label>
    <label><input id="fingersToggle" type="checkbox" checked> Animate Fingers</label>
    <div class="hint">Drag the hand to rotate, scroll to zoom</div>
  </div>

  <!-- Inline SVG: hierarchical groups for easy transforms -->
  <svg id="svg" viewBox="-600 -400 1200 800" xmlns="http://www.w3.org/2000/svg" class="draggable" role="img" aria-label="Animated robotic hand">
    <defs>
      <filter id="soft" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur stdDeviation="2" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <linearGradient id="metal" x1="0" x2="1">
        <stop offset="0" stop-color="#dfe8fb"/>
        <stop offset="0.5" stop-color="#aebbd9"/>
        <stop offset="1" stop-color="#6f7890"/>
      </linearGradient>
    </defs>

    <!-- Scene root: allows orbit/rotation -->
    <g id="scene" transform="translate(0,40) scale(1)">
      <!-- subtle ground reflection -->
      <ellipse cx="0" cy="360" rx="260" ry="30" fill="#05060a" opacity="0.4"/>

      <!-- arm group (forearm + wrist) -->
      <g id="armGroup">
        <!-- forearm -->
        <rect id="forearm" x="-70" y="-360" width="140" height="260" rx="30" ry="30" fill="url(#metal)" opacity="0.98" filter="url(#soft)"/>
        <!-- wrist plate -->
        <rect id="wristPlate" x="-80" y="-110" width="160" height="40" rx="18" ry="18" fill="#5f6a82"/>

        <!-- palm + fingers group (this group is rotated by the wave) -->
        <g id="wristPivot" transform="translate(0,-90)">
          <!-- palm -->
          <g id="palmGroup">
            <rect id="palm" x="-160" y="-90" width="320" height="160" rx="28" ry="28" fill="url(#metal)" stroke="#243042" stroke-width="2"/>
            <!-- thumb group (left) -->
            <g id="thumbBase" transform="translate(-120, -40) rotate(-40)">
              <rect x="-14" y="-18" width="28" height="72" rx="12" ry="12" fill="#d8c5b2" opacity="0.12"/>
              <rect x="-14" y="-18" width="28" height="72" rx="12" ry="12" fill="#8b6b52" transform="translate(0,0)"/>
              <rect id="thumbTip" x="-12" y="46" width="24" height="48" rx="10" ry="10" fill="#7b5d44"/>
            </g>

            <!-- finger groups: (4) arranged across top of palm, each is hierarchical -->
            <!-- we place bases, mid, tip as groups so only transforms need updating -->
            <g id="fingers">
              <!-- positions are symmetric & compact -->
              <g id="finger0" transform="translate(-80,-68)"><rect x="-12" y="-8" width="24" height="68" rx="10" ry="10" fill="#9fb8ff" opacity="0.05"/><rect class="seg base" x="-12" y="-8" width="24" height="68" rx="10" ry="10" fill="#9fb8ff"/></g>
              <g id="finger1" transform="translate(-30,-78)"><rect x="-10" y="-10" width="20" height="78" rx="9" ry="9" fill="#9fb8ff" opacity="0.05"/><rect class="seg base" x="-10" y="-10" width="20" height="78" rx="9" ry="9" fill="#8aa6ff"/></g>
              <g id="finger2" transform="translate(30,-78)"><rect x="-10" y="-10" width="20" height="78" rx="9" ry="9" fill="#9fb8ff" opacity="0.05"/><rect class="seg base" x="-10" y="-10" width="20" height="78" rx="9" ry="9" fill="#8aa6ff"/></g>
              <g id="finger3" transform="translate(80,-68)"><rect x="-12" y="-8" width="24" height="68" rx="10" ry="10" fill="#9fb8ff" opacity="0.05"/><rect class="seg base" x="-12" y="-8" width="24" height="68" rx="10" ry="10" fill="#9fb8ff"/></g>
            </g>

            <!-- decorative center panel -->
            <rect x="-40" y="8" width="80" height="34" rx="8" ry="8" fill="#42506a" opacity="0.5"/>
          </g>
        </g>
      </g>

      <!-- a small ambient glow to make it feel livelier -->
      <g id="highlights" opacity="0.08">
        <ellipse cx="40" cy="-180" rx="160" ry="100" fill="#9fb8ff"/>
      </g>
    </g>
  </svg>
</div>

<script>
/* Efficient SVG hierarchical animation:
   - single RAF loop
   - only updating 'transform' attributes (minimal DOM writes)
   - lightweight math and small object caches
*/

// Grab elements once
const svg = document.getElementById('svg');
const scene = document.getElementById('scene');
const armGroup = document.getElementById('armGroup');
const wristPivot = document.getElementById('wristPivot');
const fingers = [
  document.getElementById('finger0'),
  document.getElementById('finger1'),
  document.getElementById('finger2'),
  document.getElementById('finger3')
];
const thumbBase = document.getElementById('thumbBase');
const thumbTip = document.getElementById('thumbTip');

const speedEl = document.getElementById('speed');
const fingersToggle = document.getElementById('fingersToggle');

let start = performance.now();
let running = true;

// Camera-like interactivity (rotate & zoom)
let drag = false, last = null;
let sceneRot = {x: -12, y: 0}; // degrees, x = tilt (up/down), y = yaw
let sceneScale = 1;
svg.addEventListener('pointerdown', e => { drag=true; last=[e.clientX,e.clientY]; svg.setPointerCapture(e.pointerId); svg.style.cursor='grabbing'; });
window.addEventListener('pointerup', e => { drag=false; last=null; svg.style.cursor='grab'; });
window.addEventListener('pointermove', e => {
  if(!drag || !last) return;
  const dx = e.clientX - last[0], dy = e.clientY - last[1];
  last = [e.clientX, e.clientY];
  sceneRot.y += dx * 0.25;
  sceneRot.x = Math.max(-40, Math.min(40, sceneRot.x + dy * 0.18));
  updateSceneTransform();
});
svg.addEventListener('wheel', e => {
  e.preventDefault();
  sceneScale *= Math.pow(1.02, -e.deltaY/40);
  sceneScale = Math.max(0.6, Math.min(1.6, sceneScale));
  updateSceneTransform();
}, {passive:false});

function updateSceneTransform(){
  // apply rotation and scale to scene group; center pivot is around (0,40) per viewBox
  scene.setAttribute('transform', `translate(0,40) scale(${sceneScale}) rotate(${sceneRot.y}) translate(0,0) rotate(${sceneRot.x} 0 0)`);
}
updateSceneTransform();

// Utility: create transform strings
const T = {
  translate: (x,y) => `translate(${(x||0).toFixed(3)},${(y||0).toFixed(3)})`,
  rotate: (a, x=0, y=0) => `rotate(${a.toFixed(3)} ${x} ${y})`,
  combine: (parts) => parts.join(' ')
};

// Precompute finger base positions to use as rotation origins (where finger meets palm)
const fingerOrigins = [
  {x:-80, y:-30}, {x:-30,y:-40}, {x:30,y:-40}, {x:80,y:-30}
];
const thumbOrigin = {x:-120, y:-40};

// Small easing for "snappy" feel
function fastOvershoot(t){
  // quick sinusoidal overshoot, returns modifier for angle amplitude
  return (Math.sin(t*1.8) * 0.25 + 0.75);
}

// Animation loop
function frame(now){
  const t = (now - start)/1000;
  const speed = Math.max(0.001, parseFloat(speedEl.value) || 1);

  // wrist wave = combination of sin waves --> larger, snappy amplitude
  const wristAngle = Math.sin(t * 2.0 * speed) * 24 * fastOvershoot(t*speed) + Math.sin(t * 4.5 * speed) * 4;
  // apply to wristPivot (rotate around its local origin: group is already positioned)
  wristPivot.setAttribute('transform', `translate(0,-90) ${T.rotate(wristAngle)}`);

  // Forearm subtle lean (counter to wrist so wave looks natural)
  const forearmLean = Math.sin(t * 1.0 * speed) * 4;
  document.getElementById('forearm').setAttribute('transform', `translate(0,0) rotate(${forearmLean})`);

  // Thumb articulation (two joints) — make it look alive
  const thumbCurl = Math.max(-10, Math.sin(t*2.3*speed - 0.6)*38); // degrees
  thumbBase.setAttribute('transform', `${T.translate(thumbOrigin.x,thumbOrigin.y)} rotate(-40) translate(0,0) rotate(${thumbCurl})`);
  // thumb tip small secondary curl
  thumbTip.setAttribute('transform', `translate(0,46) rotate(${Math.max(-18, thumbCurl*0.45)})`);

  // Fingers: consider toggle for less DOM activity
  const animateFingers = fingersToggle.checked;
  for(let i=0;i<fingers.length;i++){
    const fg = fingers[i];
    const origin = fingerOrigins[i];
    if(!animateFingers){
      // set to relaxed open pose (static)
      fg.setAttribute('transform', `translate(${origin.x},${origin.y}) rotate(0)`);
      fg.classList.add('muted');
      continue;
    }
    fg.classList.remove('muted');

    // curling: faster for inner fingers, slightly offset phase per finger
    const phase = i * 0.35;
    const baseCurl = Math.max(0, Math.sin(t * 3.0 * speed - phase) * 1.0); // 0..1
    // map to degrees with a snappy ease (quick close, softer open)
    const curlDeg = (Math.pow(baseCurl, 0.9) * 60 + Math.pow(baseCurl,1.6) * 18); // combine for shape
    // small lateral sway to add life
    const lateral = Math.sin(t * 1.5 * speed + i) * 2.5;
    fg.setAttribute('transform', `${T.translate(origin.x, origin.y)} rotate(${ -curlDeg }) translate(0,0) rotate(${lateral})`);
  }

  // cheap performance trick: do not call too many DOM writes if speed tiny (but user rarely sets to 0)
  if(running) requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// Pause/resume on page visibility to save CPU
document.addEventListener('visibilitychange', () => {
  if(document.hidden){ running=false; } else { if(!running){ running=true; start = performance.now() - ( (performance.now()-start) % 1000 ); requestAnimationFrame(frame); } }
});

// small accessibility: keyboard toggles
window.addEventListener('keydown', e => {
  if(e.key === 'f') fingersToggle.checked = !fingersToggle.checked;
  if(e.key === ' ') { // space to toggle speed between 0 and 1
    speedEl.value = (Math.abs(parseFloat(speedEl.value)) < 0.001) ? 1 : 0;
  }
});
</script>
</body>
</html>
