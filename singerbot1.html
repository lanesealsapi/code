<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Type & Sing — Black & Yellow</title>
<style>
  :root{
    --bg:#000;
    --fg:#ffd400;
    --muted:#bfa800;
    --panel:#111;
    --glass: rgba(255,212,0,0.06);
    --accent:#ffea61;
    --danger:#ff7575;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{
    height:100%;
    margin:0;
    background: linear-gradient(180deg,#000 0%, #0a0a0a 100%);
    color:var(--fg);
  }
  .wrap{
    max-width:900px;
    margin:32px auto;
    padding:28px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,212,0,0.08);
    border-radius:12px;
    box-shadow: 0 6px 30px rgba(0,0,0,0.7);
  }
  header{
    display:flex;
    gap:16px;
    align-items:center;
  }
  .logo{
    width:64px;height:64px;border-radius:12px;
    background:linear-gradient(135deg,var(--fg),var(--muted));
    display:flex;align-items:center;justify-content:center;
    color:#000;font-weight:800;font-size:20px;
    box-shadow: 0 4px 18px rgba(255,212,0,0.08) inset;
  }
  h1{margin:0;font-size:20px}
  p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}
  main{margin-top:18px;display:grid;grid-template-columns:1fr 320px;gap:18px}
  .panel{
    background:var(--panel);
    border-radius:10px;
    padding:12px;
    border:1px solid rgba(255,212,0,0.04);
  }
  textarea{
    width:100%;min-height:260px;background:transparent;border:1px dashed rgba(255,212,0,0.08);
    color:var(--fg);padding:12px;border-radius:8px;font-size:15px;resize:vertical;
  }
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  .controls{display:flex;gap:10px;align-items:center;margin-top:10px;flex-wrap:wrap}
  button, select{
    background:linear-gradient(180deg, rgba(255,212,0,0.12), rgba(255,212,0,0.04));
    color:#000;border:0;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
  }
  button.secondary{
    background:transparent;color:var(--fg);border:1px solid rgba(255,212,0,0.06);font-weight:600;
  }
  .small{font-size:13px;padding:6px 8px}
  .row{display:flex;gap:8px;align-items:center}
  .meter{height:8px;background:rgba(255,255,255,0.03);border-radius:6px;overflow:hidden}
  .meter > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#ffd400);width:0%}
  .voices{max-height:160px;overflow:auto;padding:6px;border-radius:6px}
  .note{
    display:inline-block;background:var(--glass);padding:6px 8px;border-radius:6px;margin:4px;font-size:13px;color:var(--fg);
  }
  footer{margin-top:14px;color:var(--muted);font-size:13px}
  .muted{color:var(--muted)}
  .danger{color:var(--danger);background:transparent;border:1px solid rgba(255,0,0,0.06)}
  .kbd{background:#111;padding:4px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-family:monospace;font-size:13px}
  @media (max-width:880px){
    main{grid-template-columns:1fr; }
  }
</style>
</head>
<body>
<div class="wrap" role="application" aria-label="Type and Sing app">
  <header>
    <div class="logo">TS</div>
    <div>
      <h1>Type & Sing</h1>
      <p class="lead">Enter text and press Sing. Uses browser speech synthesis to sing your words.</p>
    </div>
  </header>

  <main>
    <section class="panel" aria-label="Composer">
      <label for="inputText">Text to sing</label>
      <textarea id="inputText" placeholder="Type a line, a poem, or lyrics...">Hello, this is a test of singing with the browser speech synthesizer.</textarea>

      <div class="controls" style="margin-top:12px">
        <div class="row">
          <label class="muted" style="margin-right:8px">Melody</label>
          <select id="melody">
            <option value="scale">Simple scale</option>
            <option value="arpeggio">Arpeggio</option>
            <option value="random">Random</option>
            <option value="sway">Sway</option>
          </select>
        </div>

        <div class="row">
          <label class="muted" style="margin-right:8px">Syllable length</label>
          <select id="syllLen">
            <option value="short">Short</option>
            <option value="medium" selected>Medium</option>
            <option value="long">Long</option>
          </select>
        </div>

        <div style="margin-left:auto" class="row">
          <button id="singBtn">Sing</button>
          <button id="stopBtn" class="secondary">Stop</button>
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap">
        <div>
          <label class="muted">Voice</label>
          <div class="voices panel" id="voiceList" style="background:transparent;border:0;padding:0"></div>
        </div>

        <div>
          <label class="muted">Rate</label>
          <input id="rate" type="range" min="0.4" max="2.0" step="0.05" value="1" />
        </div>

        <div>
          <label class="muted">Global pitch</label>
          <input id="pitch" type="range" min="0.1" max="2.0" step="0.05" value="1" />
        </div>
      </div>

      <div style="margin-top:12px" aria-hidden="true">
        <div class="muted">Tips: try short lines, pick different voices, and adjust rate/pitch for musical effect. Use the <span class="kbd">S</span> key to sing quickly.</div>
      </div>
    </section>

    <aside class="panel" aria-label="Playback & visualization">
      <div style="display:flex;flex-direction:column;gap:12px">
        <div>
          <label class="muted">Playback meter</label>
          <div class="meter"><i id="meterBar"></i></div>
        </div>

        <div>
          <label class="muted">Generated melody (notes)</label>
          <div id="notes" style="min-height:80px"></div>
        </div>

        <div>
          <label class="muted">Syllable preview</label>
          <div id="syllPreview" style="min-height:40px"></div>
        </div>

        <div>
          <label class="muted">Status</label>
          <div id="status" class="muted">idle</div>
        </div>
      </div>
    </aside>
  </main>

  <footer>
    <div class="muted">This app uses your browser's speech synthesis. Voice set depends on your device/browser.</div>
  </footer>
</div>

<script>
/* ======= Type & Sing — Standalone =======
   Uses SpeechSynthesis to approximate singing by speaking short fragments
   while changing the utterance pitch and rate.                        */
(() => {
  const input = document.getElementById('inputText');
  const singBtn = document.getElementById('singBtn');
  const stopBtn = document.getElementById('stopBtn');
  const voiceList = document.getElementById('voiceList');
  const rateEl = document.getElementById('rate');
  const pitchEl = document.getElementById('pitch');
  const melodySel = document.getElementById('melody');
  const syllLenSel = document.getElementById('syllLen');
  const meterBar = document.getElementById('meterBar');
  const notesEl = document.getElementById('notes');
  const syllPreview = document.getElementById('syllPreview');
  const statusEl = document.getElementById('status');

  const synth = window.speechSynthesis;
  let voices = [];
  let playing = false;
  let stopRequested = false;

  function loadVoices(){
    voices = synth.getVoices().sort((a,b)=>a.name.localeCompare(b.name));
    voiceList.innerHTML = '';
    voices.forEach((v,i)=>{
      const btn = document.createElement('button');
      btn.className = 'small';
      btn.textContent = v.name + (v.default ? ' • default' : '');
      btn.title = `${v.lang} ${v.name}`;
      btn.onclick = ()=> selectVoice(i);
      voiceList.appendChild(btn);
    });
    if(!voices.length){
      const p=document.createElement('div');
      p.className='muted';
      p.textContent='No voices available — check browser/OS settings.';
      voiceList.appendChild(p);
    }
  }
  loadVoices();
  if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = loadVoices;
  }

  function selectVoice(index){
    selectedVoiceIndex = index;
    updateVoiceButtons();
  }
  let selectedVoiceIndex = 0;
  function updateVoiceButtons(){
    [...voiceList.children].forEach((b, i)=> b.style.outline = (i===selectedVoiceIndex)?'2px solid rgba(255,212,0,0.18)':'none');
  }

  function setStatus(s){
    statusEl.textContent = s;
  }

  function textToSyllables(text){
    // Very simple syllable splitter: break by vowels groups, keep punctuation as separate tokens.
    // Not linguistically perfect, but works decently for short demo singing.
    const parts = [];
    const words = text.split(/\s+/).filter(Boolean);
    const vowel = /[aeiouyAEIOUY]/;
    words.forEach((w) => {
      let token = '';
      for (let i=0;i<w.length;i++){
        const ch = w[i];
        token += ch;
        const next = w[i+1] || '';
        if (vowel.test(ch) && (!vowel.test(next) || next==='')) {
          // end of a vowel group -> split syllable
          parts.push(token);
          token = '';
        } else if (/[.,;:!?-]/.test(ch)){
          if (token.trim()) parts.push(token);
          token='';
        }
      }
      if (token) parts.push(token);
      parts.push(' '); // word spacer
    });
    // clean empty
    return parts.filter(p=>p!==undefined && p!==null && p.length>0);
  }

  function generateMelody(syllables, mode='scale'){
    // Represent melody as relative semitone offsets from tonic (0)
    const scale = [0,2,4,5,7,9,11,12]; // major-ish
    const arpeggio = [0,4,7,12,7,4];
    const sway = [0,2,0,-1,2,0];
    const out = [];
    for (let i=0;i<syllables.length;i++){
      if (syllables[i].trim()==='') { out.push(null); continue; }
      let idx = 0;
      if (mode==='scale') idx = scale[i % scale.length];
      else if (mode==='arpeggio') idx = arpeggio[i % arpeggio.length];
      else if (mode==='sway') idx = sway[i % sway.length];
      else if (mode==='random') idx = Math.floor(Math.random()*12) - 5;
      out.push(idx);
    }
    return out;
  }

  function noteToPitchRatio(semitones){
    // Convert semitone difference to pitch ratio for SpeechSynthesis.pitch control.
    // pitch value roughly 0.1..2.0 in many engines; we map semitones to multiplier around 1.
    return Math.pow(2, semitones/12);
  }

  function displayNotes(melody){
    notesEl.innerHTML = '';
    melody.forEach((n, i)=>{
      const span = document.createElement('span');
      span.className = 'note';
      span.textContent = (n===null ? 'rest' : (n>0?`+${n}`:n));
      notesEl.appendChild(span);
    });
  }

  function previewSyllables(syll){
    syllPreview.innerHTML = '';
    syll.forEach(s => {
      const sEl = document.createElement('span');
      sEl.className = 'note';
      sEl.style.background = 'transparent';
      sEl.style.border = '1px dashed rgba(255,212,0,0.06)';
      sEl.textContent = s;
      syllPreview.appendChild(sEl);
    });
  }

  function speakSyllable(textChunk, baseRate, basePitch, pitchRatio, voiceIndex, onEnd){
    return new Promise((resolve)=>{
      const utt = new SpeechSynthesisUtterance(textChunk);
      utt.rate = Math.max(0.1, Math.min(2.5, baseRate));
      // combine basePitch and pitchRatio, ensure inside typical [0.1,2]
      let p = basePitch * pitchRatio;
      p = Math.max(0.1, Math.min(2.5, p));
      utt.pitch = p;
      if (voices[voiceIndex]) utt.voice = voices[voiceIndex];
      utt.onend = (e) => { resolve(); if(onEnd) onEnd(); };
      utt.onerror = (e) => { resolve(); };
      synth.speak(utt);
    });
  }

  function setMeter(percent){
    meterBar.style.width = percent + '%';
  }

  async function singText(text){
    if (!synth) { setStatus('Speech not supported'); return; }
    stopRequested = false;
    setStatus('preparing');
    const sylls = textToSyllables(text);
    previewSyllables(sylls);
    const melody = generateMelody(sylls, melodySel.value);
    displayNotes(melody);

    const syllLen = syllLenSel.value;
    let baseSyllTime = (syllLen==='short')?140 : (syllLen==='long')?330 : 220; // ms
    const baseRate = parseFloat(rateEl.value);
    const basePitch = parseFloat(pitchEl.value);
    const voiceIndex = selectedVoiceIndex || 0;

    setStatus('singing');
    playing = true;

    for (let i=0;i<sylls.length;i++){
      if (stopRequested) break;
      const s = sylls[i];
      const n = melody[i];
      const displayIndex = Math.round((i/sylls.length)*100);
      setMeter(displayIndex);
      // Pause for spaces
      if (s.trim()==='') {
        await new Promise(r=>setTimeout(r, baseSyllTime));
        continue;
      }
      // short fragment (one or two chars) to sound musical
      const chunk = s.length>3 ? s.slice(0,3) : s;
      const semitone = (n===null)?0:n;
      const pitchRatio = noteToPitchRatio(semitone);
      // Slight randomness to timing and rate for variation
      const rateMod = baseRate * (0.85 + Math.random()*0.4);
      // Combine into utterance
      await speakSyllable(chunk, rateMod, basePitch, pitchRatio, voiceIndex);
      // small gap between syllables
      await new Promise(r=>setTimeout(r, baseSyllTime * (0.5 + Math.random()*0.7)));
      if (stopRequested) break;
    }

    setMeter(100);
    playing = false;
    setStatus(stopRequested? 'stopped' : 'finished');
    setTimeout(()=>setMeter(0), 300);
  }

  singBtn.addEventListener('click', ()=>{
    if (playing){ stopRequested = true; synth.cancel(); setStatus('stop requested'); return; }
    const text = input.value.trim();
    if (!text) { setStatus('enter text'); return; }
    // choose first voice if not set
    if (voices.length && !voiceList.children[selectedVoiceIndex]){
      selectedVoiceIndex = 0;
    }
    singText(text).catch(e => { console.error(e); setStatus('error'); });
  });

  stopBtn.addEventListener('click', ()=>{
    stopRequested = true;
    try { synth.cancel(); } catch(e){}
    setStatus('stop requested');
  });

  // keyboard quick sing: press "S"
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() === 's' && !e.metaKey && !e.ctrlKey && !e.altKey){
      e.preventDefault();
      singBtn.click();
    }
  });

  // set initial voice selection UI state
  updateVoiceButtons();
  // try to load voices after a short delay (some engines populate later)
  setTimeout(loadVoices, 250);

})();
</script>
</body>
</html>
