<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Butterfly Effect Swarm with Smooth Chord</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    height: 100%;
    width: 100%;
    cursor: crosshair;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
});

const sigma = 10, rho = 28, beta = 8/3;
let dt = 0.01;

class Particle {
  constructor(x, y, color) {
    this.x = x; this.y = y; this.z = Math.random()*30;
    this.prevX = x; this.prevY = y; this.color = color;
    this.vx = Math.random()*0.1; this.vy = Math.random()*0.1; this.vz = Math.random()*0.1;
    this.size = Math.random()*1.5 + 0.5;
    this.glowIntensity = Math.random()*20 + 10;
  }

  getVelocityMagnitude() { return Math.sqrt(this.vx*this.vx + this.vy*this.vy + this.vz*this.vz); }

  update() {
    const dx = sigma*(this.y-this.x)*dt;
    const dy = (this.x*(rho-this.z)-this.y)*dt;
    const dz = (this.x*this.y - beta*this.z)*dt;
    this.vx += dx; this.vy += dy; this.vz += dz;
    this.prevX = this.x; this.prevY = this.y;
    this.x += this.vx; this.y += this.vy;
    this.glowIntensity = 10 + 10*Math.sin(Date.now()*0.005 + this.x + this.y);
  }

  draw(ctx) {
    ctx.strokeStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = this.glowIntensity;
    ctx.lineWidth = this.size;
    ctx.beginPath();
    ctx.moveTo(this.prevX + width/2, this.prevY + height/2);
    ctx.lineTo(this.x + width/2, this.y + height/2);
    ctx.stroke();
  }
}

let particles = [];

function posToColor(x,y) {
  const r = Math.floor(150 + 105*x/width);
  const g = Math.floor(150 + 105*y/height);
  const b = 255 - r;
  return `rgb(${r},${g},${b})`;
}

// Audio setup
const AudioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSmoothChord() {
  const baseFreq = 210 + Math.random()*10;
  const chordIntervals = [0,2,4,5,7];
  const duration = 2; // fade out in 2s
  const startTime = AudioCtx.currentTime;
  const oscillators = [];
  const gains = [];

  chordIntervals.forEach(interval => {
    const osc = AudioCtx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.value = baseFreq * Math.pow(2, interval/12);
    const gain = AudioCtx.createGain();
    gain.gain.setValueAtTime(0, startTime);
    osc.connect(gain); gain.connect(AudioCtx.destination);
    osc.start(startTime);
    osc.stop(startTime + duration);
    oscillators.push(osc); gains.push(gain);
  });

  function updateChord() {
    const totalVelocity = particles.reduce((sum,p)=>sum+p.getVelocityMagnitude(),0);
    const avgVelocity = totalVelocity/(particles.length||1);
    const scale = Math.min(avgVelocity*0.05,0.15);

    gains.forEach(g=>{
      // Smooth gain envelope
      g.gain.setTargetAtTime(scale, AudioCtx.currentTime, 0.05);
      // Fade to 0 over 2 seconds from start
      g.gain.setTargetAtTime(0, startTime + duration, 0.05);
    });

    oscillators.forEach((osc,i)=>{
      const mod = Math.sin(Date.now()*0.001 + i)*avgVelocity*0.2;
      osc.frequency.setTargetAtTime(osc.frequency.value*(1 + mod*0.005), AudioCtx.currentTime, 0.05);
    });

    if(AudioCtx.currentTime < startTime + duration) requestAnimationFrame(updateChord);
  }

  updateChord();
}

canvas.addEventListener('click', e => {
  const color = posToColor(e.clientX, e.clientY);
  for(let i=0;i<60;i++){
    particles.push(new Particle((Math.random()-0.5)*10, (Math.random()-0.5)*10, color));
  }
  playSmoothChord();
});

function animate() {
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(0,0,width,height);
  for(const p of particles){ p.update(); p.draw(ctx); }
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
